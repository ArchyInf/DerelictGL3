/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/
module derelict.opengl3.arb;

private {
    import derelict.util.system;
    import derelict.opengl3.internal.types;
    import derelict.opengl3.internal.constants;
    import derelict.opengl3.internal.common;
    import derelict.opengl3.internal.funcmix;
}

public import derelict.opengl3.internal.arb;

private __gshared bool _ARB_depth_buffer_float;
bool ARB_depth_buffer_float() @property { return _ARB_depth_buffer_float; }

private __gshared bool _ARB_framebuffer_sRGB;
bool ARB_framebuffer_sRGB() @property { return _ARB_framebuffer_sRGB; }

private __gshared bool _ARB_half_float_vertex;
bool ARB_half_float_vertex() @property { return _ARB_half_float_vertex; }

private __gshared bool _ARB_texture_compression_rgtc;
bool ARB_texture_compression_rgtc() @property { return _ARB_texture_compression_rgtc; }

private __gshared bool _ARB_texture_rg;
bool ARB_texture_rg() @property { return _ARB_texture_rg; }

private __gshared bool _ARB_depth_clamp;
bool ARB_depth_clamp() @property { return _ARB_depth_clamp; }

private __gshared bool _ARB_fragment_coord_conventions;
bool ARB_fragment_coord_conventions() @property { return _ARB_fragment_coord_conventions; }

private __gshared bool _ARB_seamless_cube_map;
bool ARB_seamless_cube_map() @property { return _ARB_seamless_cube_map; }

private __gshared bool _ARB_vertex_array_bgra;
bool ARB_vertex_array_bgra() @property { return _ARB_vertex_array_bgra; }

private __gshared bool _ARB_texture_cube_map_array;
bool ARB_texture_cube_map_array() @property { return _ARB_texture_cube_map_array; }

private __gshared bool _ARB_texture_gather;
bool ARB_texture_gather() @property { return _ARB_texture_gather; }

private __gshared bool _ARB_texture_query_lod;
bool ARB_texture_query_lod() @property { return _ARB_texture_query_lod; }

private __gshared bool _ARB_texture_compression_bptc;
bool ARB_texture_compression_bptc() @property { return _ARB_texture_compression_bptc; }

private __gshared bool _ARB_explicit_attrib_location;
bool ARB_explicit_attrib_location() @property { return _ARB_explicit_attrib_location; }

private __gshared bool _ARB_occlusion_query2;
bool ARB_occlusion_query2() @property { return _ARB_occlusion_query2; }

private __gshared bool _ARB_shader_bit_encoding;
bool ARB_shader_bit_encoding() @property { return _ARB_shader_bit_encoding; }

private __gshared bool _ARB_texture_rgb10_a2ui;
bool ARB_texture_rgb10_a2ui() @property { return _ARB_texture_rgb10_a2ui; }

private __gshared bool _ARB_texture_swizzle;
bool ARB_texture_swizzle() @property { return _ARB_texture_swizzle; }

private __gshared bool _ARB_gpu_shader5;
bool ARB_gpu_shader5() @property { return _ARB_gpu_shader5; }

private __gshared bool _ARB_texture_buffer_object_rgb32;
bool ARB_texture_buffer_object_rgb32() @property { return _ARB_texture_buffer_object_rgb32; }

private __gshared bool _ARB_shader_precision;
bool ARB_shader_precision() @property { return _ARB_shader_precision; }

private __gshared bool _ARB_shader_stencil_export;
bool ARB_shader_stencil_export() @property { return _ARB_shader_stencil_export; }

private __gshared bool _ARB_shading_language_420pack;
bool ARB_shading_language_420pack() @property { return _ARB_shading_language_420pack; }

private __gshared bool _ARB_compressed_texture_pixel_storage;
bool ARB_compressed_texture_pixel_storage() @property { return _ARB_compressed_texture_pixel_storage; }

private __gshared bool _ARB_conservative_depth;
bool ARB_conservative_depth() @property { return _ARB_conservative_depth; }

private __gshared bool _ARB_map_buffer_alignment;
bool ARB_map_buffer_alignment() @property { return _ARB_map_buffer_alignment; }

private __gshared bool _ARB_shading_language_packing;
bool ARB_shading_language_packing() @property { return _ARB_shading_language_packing; }

// ARB_framebuffer_object
private __gshared bool _ARB_framebuffer_object;
bool ARB_framebuffer_object() @property { return _ARB_framebuffer_object; }
package void load_ARB_framebuffer_object( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glIsRenderbuffer, "glIsRenderbuffer" );
        bindGLFunc( cast( void** )&glBindRenderbuffer, "glBindRenderbuffer" );
        bindGLFunc( cast( void** )&glDeleteRenderbuffers, "glDeleteRenderbuffers" );
        bindGLFunc( cast( void** )&glGenRenderbuffers, "glGenRenderbuffers" );
        bindGLFunc( cast( void** )&glRenderbufferStorage, "glRenderbufferStorage" );
        bindGLFunc( cast( void** )&glGetRenderbufferParameteriv, "glGetRenderbufferParameteriv" );
        bindGLFunc( cast( void** )&glIsFramebuffer, "glIsFramebuffer" );
        bindGLFunc( cast( void** )&glBindFramebuffer, "glBindFramebuffer" );
        bindGLFunc( cast( void** )&glDeleteFramebuffers, "glDeleteFramebuffers" );
        bindGLFunc( cast( void** )&glGenFramebuffers, "glGenFramebuffers" );
        bindGLFunc( cast( void** )&glCheckFramebufferStatus, "glCheckFramebufferStatus" );
        bindGLFunc( cast( void** )&glFramebufferTexture1D, "glFramebufferTexture1D" );
        bindGLFunc( cast( void** )&glFramebufferTexture2D, "glFramebufferTexture2D" );
        bindGLFunc( cast( void** )&glFramebufferTexture3D, "glFramebufferTexture3D" );
        bindGLFunc( cast( void** )&glFramebufferRenderbuffer, "glFramebufferRenderbuffer" );
        bindGLFunc( cast( void** )&glGetFramebufferAttachmentParameteriv, "glGetFramebufferAttachmentParameteriv" );
        bindGLFunc( cast( void** )&glGenerateMipmap, "glGenerateMipmap" );
        bindGLFunc( cast( void** )&glBlitFramebuffer, "glBlitFramebuffer" );
        bindGLFunc( cast( void** )&glRenderbufferStorageMultisample, "glRenderbufferStorageMultisample" );
        bindGLFunc( cast( void** )&glFramebufferTextureLayer, "glFramebufferTextureLayer" );
        _ARB_framebuffer_object = true;
    } catch( Exception e ) {
        _ARB_framebuffer_object = false;
        if( doThrow ) throw e;
    }
}

// ARB_map_buffer_range
extern( System ) nothrow {
        alias da_glMapBufferRange = GLvoid* function( GLenum, GLintptr, GLsizeiptr, GLbitfield );
        alias da_glFlushMappedBufferRange = void function( GLenum, GLintptr, GLsizeiptr );
}
__gshared da_glMapBufferRange glMapBufferRange;
__gshared da_glFlushMappedBufferRange glFlushMappedBufferRange;

private __gshared bool _ARB_map_buffer_range;
bool ARB_map_buffer_range() @property { return _ARB_map_buffer_range; }
package void load_ARB_map_buffer_range( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glMapBufferRange, "glMapBufferRange" );
        bindGLFunc( cast( void** )&glFlushMappedBufferRange, "glFlushMappedBufferRange" );
        _ARB_map_buffer_range = true;
    } catch( Exception e ) {
        _ARB_map_buffer_range = false;
        if( doThrow ) throw e;
    }
}

// ARB_vertex_array_object
extern( System ) nothrow {
    alias da_glBindVertexArray = void function( GLuint );
    alias da_glDeleteVertexArrays = void function( GLsizei, const( GLuint )* );
    alias da_glGenVertexArrays = void function( GLsizei, GLuint* );
    alias da_glIsVertexArray = GLboolean function( GLuint );
}

__gshared {
    da_glBindVertexArray glBindVertexArray;
    da_glDeleteVertexArrays glDeleteVertexArrays;
    da_glGenVertexArrays glGenVertexArrays;
    da_glIsVertexArray glIsVertexArray;
}

private __gshared bool _ARB_vertex_array_object;
bool ARB_vertex_array_object() @property { return _ARB_vertex_array_object; }
package void load_ARB_vertex_array_object( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glBindVertexArray, "glBindVertexArray" );
        bindGLFunc( cast( void** )&glDeleteVertexArrays, "glDeleteVertexArrays" );
        bindGLFunc( cast( void** )&glGenVertexArrays, "glGenVertexArrays" );
        bindGLFunc( cast( void** )&glIsVertexArray, "glIsVertexArray" );
        _ARB_vertex_array_object = true;
    } catch( Exception e ) {
        _ARB_vertex_array_object = false;
        if( doThrow ) throw e;
    }
}

// ARB_uniform_buffer_object
extern( System ) nothrow {
    alias da_glGetUniformIndices = void function( GLuint, GLsizei, const( GLchar* )*, GLuint* );
    alias da_glGetActiveUniformsiv = void function( GLuint, GLsizei, const( GLuint )*, GLenum, GLint* );
    alias da_glGetActiveUniformName = void function( GLuint, GLuint, GLsizei, GLsizei*, GLchar* );
    alias da_glGetUniformBlockIndex = GLuint function( GLuint, const( GLchar )* );
    alias da_glGetActiveUniformBlockiv = void function( GLuint, GLuint, GLenum, GLint* );
    alias da_glGetActiveUniformBlockName = void function( GLuint, GLuint, GLsizei, GLsizei*, GLchar* );
    alias da_glUniformBlockBinding = void function( GLuint, GLuint, GLuint );
}

__gshared {
    da_glGetUniformIndices glGetUniformIndices;
    da_glGetActiveUniformsiv glGetActiveUniformsiv;
    da_glGetActiveUniformName glGetActiveUniformName;
    da_glGetUniformBlockIndex glGetUniformBlockIndex;
    da_glGetActiveUniformBlockiv glGetActiveUniformBlockiv;
    da_glGetActiveUniformBlockName glGetActiveUniformBlockName;
    da_glUniformBlockBinding glUniformBlockBinding;
}

private __gshared bool _ARB_uniform_buffer_object;
bool ARB_uniform_buffer_object() @property { return _ARB_uniform_buffer_object; }
package void load_ARB_uniform_buffer_object( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glGetUniformIndices, "glGetUniformIndices" );
        bindGLFunc( cast( void** )&glGetActiveUniformsiv, "glGetActiveUniformsiv" );
        bindGLFunc( cast( void** )&glGetActiveUniformName, "glGetActiveUniformName" );
        bindGLFunc( cast( void** )&glGetUniformBlockIndex, "glGetUniformBlockIndex" );
        bindGLFunc( cast( void** )&glGetActiveUniformBlockiv, "glGetActiveUniformBlockiv" );
        bindGLFunc( cast( void** )&glGetActiveUniformBlockName, "glGetActiveUniformBlockName" );
        bindGLFunc( cast( void** )&glUniformBlockBinding, "glUniformBlockBinding" );
        _ARB_uniform_buffer_object = true;
    } catch( Exception e ) {
        _ARB_uniform_buffer_object = true;
        if( doThrow ) throw e;
    }
}

// ARB_copy_buffer
extern( System ) nothrow alias da_glCopyBufferSubData = void function( GLenum, GLenum, GLintptr, GLintptr, GLsizeiptr );
__gshared da_glCopyBufferSubData glCopyBufferSubData;

private __gshared bool _ARB_copy_buffer;
bool ARB_copy_buffer() @property { return _ARB_copy_buffer; }
package void load_ARB_copy_buffer( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glCopyBufferSubData, "glCopyBufferSubData" );
        _ARB_copy_buffer = true;
    } catch( Exception e ) {
        _ARB_copy_buffer = false;
        if( doThrow ) throw e;
    }
}

// ARB_draw_elements_base_vertex
extern( System ) nothrow {
    alias da_glDrawElementsBaseVertex = void function( GLenum, GLsizei, GLenum, const( GLvoid )*, GLint );
    alias da_glDrawRangeElementsBaseVertex = void function( GLenum, GLuint, GLuint, GLsizei, GLenum, const( GLvoid )*, GLint );
    alias da_glDrawElementsInstancedBaseVertex = void function( GLenum, GLsizei, GLenum, const( GLvoid )*, GLsizei, GLint );
    alias da_glMultiDrawElementsBaseVertex = void function( GLenum, const( GLsizei )*, GLenum, const( GLvoid* )*, GLsizei, const( GLint )* );
}

__gshared {
    da_glDrawElementsBaseVertex glDrawElementsBaseVertex;
    da_glDrawRangeElementsBaseVertex glDrawRangeElementsBaseVertex;
    da_glDrawElementsInstancedBaseVertex glDrawElementsInstancedBaseVertex;
    da_glMultiDrawElementsBaseVertex glMultiDrawElementsBaseVertex;
}

private __gshared bool _ARB_draw_elements_base_vertex;
bool ARB_draw_elements_base_vertex() @property { return _ARB_draw_elements_base_vertex; }
package void load_ARB_draw_elements_base_vertex( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glDrawElementsBaseVertex, "glDrawElementsBaseVertex" );
        bindGLFunc( cast( void** )&glDrawRangeElementsBaseVertex, "glDrawRangeElementsBaseVertex" );
        bindGLFunc( cast( void** )&glDrawElementsInstancedBaseVertex, "glDrawElementsInstancedBaseVertex" );
        bindGLFunc( cast( void** )&glMultiDrawElementsBaseVertex, "glMultiDrawElementsBaseVertex" );
        _ARB_draw_elements_base_vertex = true;
    } catch( Exception e ) {
        _ARB_draw_elements_base_vertex = false;
        if( doThrow ) throw e;
    }
}

// ARB_provoking_vertex
extern( System ) nothrow alias da_glProvokingVertex = void function( GLenum );
__gshared da_glProvokingVertex glProvokingVertex;

private __gshared bool _ARB_provoking_vertex;
bool ARB_provoking_vertex() @property { return _ARB_provoking_vertex; }
package void load_ARB_provoking_vertex( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glProvokingVertex, "glProvokingVertex" );
        _ARB_provoking_vertex = true;
    } catch( Exception e ) {
        _ARB_provoking_vertex = false;
        if( doThrow ) throw e;
    }
}

// ARB_sync
extern( System ) nothrow {
    alias da_glFenceSync = GLsync function( GLenum, GLbitfield );
    alias da_glIsSync = GLboolean function( GLsync );
    alias da_glDeleteSync = void function( GLsync );
    alias da_glClientWaitSync = GLenum function( GLsync, GLbitfield, GLuint64 );
    alias da_glWaitSync = void function( GLsync, GLbitfield, GLuint64 );
    alias da_glGetInteger64v = void function( GLsync, GLint64* );
    alias da_glGetSynciv = void function( GLsync, GLenum, GLsizei, GLsizei*, GLint* );
}

__gshared {
    da_glFenceSync glFenceSync;
    da_glIsSync glIsSync;
    da_glDeleteSync glDeleteSync;
    da_glClientWaitSync glClientWaitSync;
    da_glWaitSync glWaitSync;
    da_glGetInteger64v glGetInteger64v;
    da_glGetSynciv glGetSynciv;
}

private __gshared bool _ARB_sync;
bool ARB_sync() @property { return _ARB_sync; }
package void load_ARB_sync( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glFenceSync, "glFenceSync" );
        bindGLFunc( cast( void** )&glIsSync, "glIsSync" );
        bindGLFunc( cast( void** )&glDeleteSync, "glDeleteSync" );
        bindGLFunc( cast( void** )&glClientWaitSync, "glClientWaitSync" );
        bindGLFunc( cast( void** )&glWaitSync, "glWaitSync" );
        bindGLFunc( cast( void** )&glGetInteger64v, "glGetInteger64v" );
        bindGLFunc( cast( void** )&glGetSynciv, "glGetSynciv" );
        _ARB_sync = true;
    } catch( Exception e ) {
        _ARB_sync = false;
        if( doThrow ) throw e;
    }
}

// ARB_texture_multisample
extern( System ) nothrow {
    alias da_glTexImage2DMultisample = void function( GLenum, GLsizei, GLint, GLsizei, GLsizei, GLboolean );
    alias da_glTexImage3DMultisample = void function( GLenum, GLsizei, GLint, GLsizei, GLsizei, GLsizei, GLboolean );
    alias da_glGetMultisamplefv = void function( GLenum, GLuint, GLfloat* );
    alias da_glSampleMaski = void function( GLuint, GLbitfield );
}

__gshared {
    da_glTexImage2DMultisample glTexImage2DMultisample;
    da_glTexImage3DMultisample glTexImage3DMultisample;
    da_glGetMultisamplefv glGetMultisamplefv;
    da_glSampleMaski glSampleMaski;
}

private __gshared bool _ARB_texture_multisample;
bool ARB_texture_multisample() @property { return _ARB_texture_multisample; }
package void load_ARB_texture_multisample( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glTexImage2DMultisample, "glTexImage2DMultisample" );
        bindGLFunc( cast( void** )&glTexImage3DMultisample, "glTexImage3DMultisample" );
        bindGLFunc( cast( void** )&glGetMultisamplefv, "glGetMultisamplefv" );
        bindGLFunc( cast( void** )&glSampleMaski, "glSampleMaski" );
        _ARB_texture_multisample = true;
    } catch( Exception e ) {
        _ARB_texture_multisample = false;
        if( doThrow ) throw e;
    }
}

// ARB_draw_buffers_blend
extern( System ) nothrow {
    alias da_glBlendEquationiARB = void function( GLuint, GLenum );
    alias da_glBlendEquationSeparateiARB = void function( GLuint, GLenum, GLenum );
    alias da_glBlendFunciARB = void function( GLuint, GLenum, GLenum );
    alias da_glBlendFuncSeparateiARB = void function( GLuint, GLenum, GLenum, GLenum, GLenum );
}

__gshared {
    da_glBlendEquationiARB glBlendEquationiARB;
    da_glBlendEquationSeparateiARB glBlendEquationSeparateiARB;
    da_glBlendFunciARB glBlendFunciARB;
    da_glBlendFuncSeparateiARB glBlendFuncSeparateiARB;
}

private __gshared bool _ARB_draw_buffers_blend;
bool ARB_draw_buffers_blend() @property { return _ARB_draw_buffers_blend; }
package void load_ARB_draw_buffers_blend() {
    try {
        bindGLFunc( cast( void** )&glBlendEquationiARB, "glBlendEquationiARB" );
        bindGLFunc( cast( void** )&glBlendEquationSeparateiARB, "glBlendEquationSeparateiARB" );
        bindGLFunc( cast( void** )&glBlendFunciARB, "glBlendFunciARB" );
        bindGLFunc( cast( void** )&glBlendFuncSeparateiARB, "glBlendFuncSeparateiARB" );
        _ARB_draw_buffers_blend = true;
    } catch( Exception e ) {
        _ARB_draw_buffers_blend = false;
    }
}

// ARB_sample_shading
extern( System ) nothrow alias da_glMinSampleShadingARB = void function( GLclampf );
__gshared da_glMinSampleShadingARB glMinSampleShadingARB;

private __gshared bool _ARB_sample_shading;
bool ARB_sample_shading() @property { return _ARB_sample_shading; }
package void load_ARB_sample_shading() {
    try {
        bindGLFunc( cast( void** )&glMinSampleShadingARB, "glMinSampleShadingARB" );
        _ARB_sample_shading = true;
    } catch( Exception e ) {
        _ARB_sample_shading = false;
    }
}

// ARB_shading_language_include
extern( System ) nothrow {
    alias da_glNamedStringARB = void function( GLenum, GLint, const( GLchar )*, GLint, const( GLchar )* );
    alias da_glDeleteNamedStringARB = void function( GLint, const( GLchar )* );
    alias da_glCompileShaderIncludeARB = void function( GLuint, GLsizei, const( GLchar )*, const( GLint )* );
    alias da_glIsNamedStringARB = GLboolean function( GLint, const( GLchar )* );
    alias da_glGetNamedStringARB = void function( GLint, const( GLchar )*, GLsizei, GLint*, GLchar* );
    alias da_glGetNamedStringivARB = void function( GLint, const( GLchar )*, GLenum, GLint* );
}

__gshared {
    da_glNamedStringARB glNamedStringARB;
    da_glDeleteNamedStringARB glDeleteNamedStringARB;
    da_glCompileShaderIncludeARB glCompileShaderIncludeARB;
    da_glIsNamedStringARB glIsNamedStringARB;
    da_glGetNamedStringARB glGetNamedStringARB;
    da_glGetNamedStringivARB glGetNamedStringivARB;
}

private __gshared bool _ARB_shading_language_include;
bool ARB_shading_language_include() @property { return _ARB_shading_language_include; }
package void load_ARB_shading_language_include() {
    try {
        bindGLFunc( cast( void** )&glNamedStringARB, "glNamedStringARB" );
        bindGLFunc( cast( void** )&glDeleteNamedStringARB, "glDeleteNamedStringARB" );
        bindGLFunc( cast( void** )&glCompileShaderIncludeARB, "glCompileShaderIncludeARB" );
        bindGLFunc( cast( void** )&glIsNamedStringARB, "glIsNamedStringARB" );
        bindGLFunc( cast( void** )&glGetNamedStringARB, "glGetNamedStringARB" );
        bindGLFunc( cast( void** )&glGetNamedStringivARB, "glGetNamedStringivARB" );
        _ARB_shading_language_include = true;
    } catch( Exception e ) {
        _ARB_shading_language_include = false;
    }
}

// ARB_blend_func_extended
extern( System ) nothrow {
    alias da_glBindFragDataLocationIndexed = void function( GLuint, GLuint, GLuint, const( GLchar )* );
    alias da_glGetFragDataIndex = GLint function( GLuint, const( GLchar )* );
}

__gshared da_glBindFragDataLocationIndexed glBindFragDataLocationIndexed;
__gshared da_glGetFragDataIndex glGetFragDataIndex;

private __gshared bool _ARB_blend_func_extended;
bool ARB_blend_func_extended() @property { return _ARB_blend_func_extended; }
package void load_ARB_blend_func_extended( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glBindFragDataLocationIndexed, "glBindFragDataLocationIndexed" );
        bindGLFunc( cast( void** )&glGetFragDataIndex, "glGetFragDataIndex" );
        _ARB_blend_func_extended = true;
    } catch( Exception e ) {
        _ARB_blend_func_extended = false;
        if( doThrow ) throw e;
    }
}

// ARB_sampler_objects
extern( System ) nothrow {
    alias da_glGenSamplers = void function( GLsizei, GLuint* );
    alias da_glDeleteSamplers = void function( GLsizei, const( GLuint )* );
    alias da_glIsSampler = GLboolean function( GLuint );
    alias da_glBindSampler = void function( GLuint, GLuint );
    alias da_glSamplerParameteri = void function( GLuint, GLenum, GLint );
    alias da_glSamplerParameteriv = void function( GLuint, GLenum, const( GLint )* );
    alias da_glSamplerParameterf = void function( GLuint, GLenum, GLfloat );
    alias da_glSamplerParameterfv = void function( GLuint, GLenum, const( GLfloat )* );
    alias da_glSamplerParameterIiv = void function( GLuint, GLenum, const( GLint )* );
    alias da_glSamplerParameterIuiv = void function( GLuint, GLenum, const( GLuint )* );
    alias da_glGetSamplerParameteriv = void function( GLuint, GLenum, GLint* );
    alias da_glGetSamplerParameterIiv = void function( GLuint, GLenum, GLint* );
    alias da_glGetSamplerParameterfv = void function( GLuint, GLenum, GLfloat* );
    alias da_glGetSamplerParameterIuiv = void function( GLuint, GLenum, GLuint* );
}

__gshared {
    da_glGenSamplers glGenSamplers;
    da_glDeleteSamplers glDeleteSamplers;
    da_glIsSampler glIsSampler;
    da_glBindSampler glBindSampler;
    da_glSamplerParameteri glSamplerParameteri;
    da_glSamplerParameteriv glSamplerParameteriv;
    da_glSamplerParameterf glSamplerParameterf;
    da_glSamplerParameterfv glSamplerParameterfv;
    da_glSamplerParameterIiv glSamplerParameterIiv;
    da_glSamplerParameterIuiv glSamplerParameterIuiv;
    da_glGetSamplerParameteriv glGetSamplerParameteriv;
    da_glGetSamplerParameterIiv glGetSamplerParameterIiv;
    da_glGetSamplerParameterfv glGetSamplerParameterfv;
    da_glGetSamplerParameterIuiv glGetSamplerParameterIuiv;
}

private __gshared bool _ARB_sampler_objects;
bool ARB_sampler_objects() @property { return _ARB_sampler_objects; }
package void load_ARB_sampler_objects( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glGenSamplers, "glGenSamplers" );
        bindGLFunc( cast( void** )&glDeleteSamplers, "glDeleteSamplers" );
        bindGLFunc( cast( void** )&glIsSampler, "glIsSampler" );
        bindGLFunc( cast( void** )&glBindSampler, "glBindSampler" );
        bindGLFunc( cast( void** )&glSamplerParameteri, "glSamplerParameteri" );
        bindGLFunc( cast( void** )&glSamplerParameteriv, "glSamplerParameteriv" );
        bindGLFunc( cast( void** )&glSamplerParameterf, "glSamplerParameterf" );
        bindGLFunc( cast( void** )&glSamplerParameterfv, "glSamplerParameterfv" );
        bindGLFunc( cast( void** )&glSamplerParameterIiv, "glSamplerParameterIiv" );
        bindGLFunc( cast( void** )&glSamplerParameterIuiv, "glSamplerParameterIuiv" );
        bindGLFunc( cast( void** )&glGetSamplerParameteriv, "glGetSamplerParameteriv" );
        bindGLFunc( cast( void** )&glGetSamplerParameterIiv, "glGetSamplerParameterIiv" );
        bindGLFunc( cast( void** )&glGetSamplerParameterfv, "glGetSamplerParameterfv" );
        bindGLFunc( cast( void** )&glGetSamplerParameterIuiv, "glGetSamplerParameterIuiv" );
        _ARB_sampler_objects = true;
    } catch( Exception e ) {
        _ARB_sampler_objects = false;
        if( doThrow ) throw e;
    }
}

// ARB_timer_query
extern( System ) nothrow {
    alias da_glQueryCounter = void function( GLuint, GLenum );
    alias da_glGetQueryObjecti64v = void function( GLuint, GLenum, GLint64* );
    alias da_glGetQueryObjectui64v = void function( GLuint, GLenum, GLuint64* );
}

__gshared {
    da_glQueryCounter glQueryCounter;
    da_glGetQueryObjecti64v glGetQueryObjecti64v;
    da_glGetQueryObjectui64v glGetQueryObjectui64v;
}

private __gshared bool _ARB_timer_query;
bool ARB_timer_query() @property { return _ARB_timer_query; }
void load_ARB_timer_query( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glQueryCounter, "glQueryCounter" );
        bindGLFunc( cast( void** )&glGetQueryObjecti64v, "glGetQueryObjecti64v" );
        bindGLFunc( cast( void** )&glGetQueryObjectui64v, "glGetQueryObjectui64v" );
        _ARB_timer_query = true;
    } catch( Exception e ) {
        _ARB_timer_query = false;
        if( doThrow ) throw e;
    }
}

// ARB_vertex_type_2_10_10_10_rev
extern( System ) nothrow {
    alias da_glVertexP2ui = void function( GLenum, GLuint );
    alias da_glVertexP2uiv = void function( GLenum, const( GLuint )* );
    alias da_glVertexP3ui = void function( GLenum, GLuint );
    alias da_glVertexP3uiv = void function( GLenum, const( GLuint )* );
    alias da_glVertexP4ui = void function( GLenum, GLuint );
    alias da_glVertexP4uiv = void function( GLenum, const( GLuint )* );
    alias da_glTexCoordP1ui = void function( GLenum, GLuint );
    alias da_glTexCoordP1uiv = void function( GLenum, const( GLuint )* );
    alias da_glTexCoordP2ui = void function( GLenum, GLuint );
    alias da_glTexCoordP2uiv = void function( GLenum, const( GLuint )* );
    alias da_glTexCoordP3ui = void function( GLenum, GLuint );
    alias da_glTexCoordP3uiv = void function( GLenum, const( GLuint )* );
    alias da_glTexCoordP4ui = void function( GLenum, GLuint );
    alias da_glTexCoordP4uiv = void function( GLenum, const( GLuint )* );
    alias da_glMultiTexCoordP1ui = void function( GLenum, GLenum, GLuint );
    alias da_glMultiTexCoordP1uiv = void function( GLenum, GLenum, const( GLuint )* );
    alias da_glMultiTexCoordP2ui = void function( GLenum, GLenum, GLuint );
    alias da_glMultiTexCoordP2uiv = void function( GLenum, GLenum, const( GLuint )* );
    alias da_glMultiTexCoordP3ui = void function( GLenum, GLenum, GLuint );
    alias da_glMultiTexCoordP3uiv = void function( GLenum, GLenum, const( GLuint )* );
    alias da_glMultiTexCoordP4ui = void function( GLenum, GLenum, GLuint );
    alias da_glMultiTexCoordP4uiv = void function( GLenum, GLenum, const( GLuint )* );
    alias da_glNormalP3ui = void function( GLenum, GLuint );
    alias da_glNormalP3uiv = void function( GLenum, const( GLuint )* );
    alias da_glColorP3ui = void function( GLenum, GLuint );
    alias da_glColorP3uiv = void function( GLenum, const( GLuint )* );
    alias da_glColorP4ui = void function( GLenum, GLuint );
    alias da_glColorP4uiv = void function( GLenum, const( GLuint )* );
    alias da_glSecondaryColorP3ui = void function( GLenum, GLuint );
    alias da_glSecondaryColorP3uiv = void function( GLenum, const( GLuint )* );
    alias da_glVertexAttribP1ui = void function( GLuint, GLenum, GLboolean, GLuint );
    alias da_glVertexAttribP1uiv = void function( GLuint, GLenum, GLboolean, const( GLuint )* );
    alias da_glVertexAttribP2ui = void function( GLuint, GLenum, GLboolean, GLuint );
    alias da_glVertexAttribP2uiv = void function( GLuint, GLenum, GLboolean, const( GLuint )* );
    alias da_glVertexAttribP3ui = void function( GLuint, GLenum, GLboolean, GLuint );
    alias da_glVertexAttribP3uiv = void function( GLuint, GLenum, GLboolean, const( GLuint )* );
    alias da_glVertexAttribP4ui = void function( GLuint, GLenum, GLboolean, GLuint );
    alias da_glVertexAttribP4uiv = void function( GLuint, GLenum, GLboolean, const( GLuint )* );
}

__gshared {
    da_glVertexP2ui glVertexP2ui;
    da_glVertexP2uiv glVertexP2uiv;
    da_glVertexP3ui glVertexP3ui;
    da_glVertexP3uiv glVertexP3uiv;
    da_glVertexP4ui glVertexP4ui;
    da_glVertexP4uiv glVertexP4uiv;
    da_glTexCoordP1ui glTexCoordP1ui;
    da_glTexCoordP1uiv glTexCoordP1uiv;
    da_glTexCoordP2ui glTexCoordP2ui;
    da_glTexCoordP2uiv glTexCoordP2uiv;
    da_glTexCoordP3ui glTexCoordP3ui;
    da_glTexCoordP3uiv glTexCoordP3uiv;
    da_glTexCoordP4ui glTexCoordP4ui;
    da_glTexCoordP4uiv glTexCoordP4uiv;
    da_glMultiTexCoordP1ui glMultiTexCoordP1ui;
    da_glMultiTexCoordP1uiv glMultiTexCoordP1uiv;
    da_glMultiTexCoordP2ui glMultiTexCoordP2ui;
    da_glMultiTexCoordP2uiv glMultiTexCoordP2uiv;
    da_glMultiTexCoordP3ui glMultiTexCoordP3ui;
    da_glMultiTexCoordP3uiv glMultiTexCoordP3uiv;
    da_glMultiTexCoordP4ui glMultiTexCoordP4ui;
    da_glMultiTexCoordP4uiv glMultiTexCoordP4uiv;
    da_glNormalP3ui glNormalP3ui;
    da_glNormalP3uiv glNormalP3uiv;
    da_glColorP3ui glColorP3ui;
    da_glColorP3uiv glColorP3uiv;
    da_glColorP4ui glColorP4ui;
    da_glColorP4uiv glColorP4uiv;
    da_glSecondaryColorP3ui glSecondaryColorP3ui;
    da_glSecondaryColorP3uiv glSecondaryColorP3uiv;
    da_glVertexAttribP1ui glVertexAttribP1ui;
    da_glVertexAttribP1uiv glVertexAttribP1uiv;
    da_glVertexAttribP2ui glVertexAttribP2ui;
    da_glVertexAttribP2uiv glVertexAttribP2uiv;
    da_glVertexAttribP3ui glVertexAttribP3ui;
    da_glVertexAttribP3uiv glVertexAttribP3uiv;
    da_glVertexAttribP4ui glVertexAttribP4ui;
    da_glVertexAttribP4uiv glVertexAttribP4uiv;
}

private __gshared bool _ARB_vertex_type_2_10_10_10_rev;
bool ARB_vertex_type_2_10_10_10_rev() @property { return _ARB_vertex_type_2_10_10_10_rev; }
package void load_ARB_vertex_type_2_10_10_10_rev( bool doThrow = false ) {
    try {
        static if( !Derelict_OS_Mac ) {
            bindGLFunc( cast( void** )&glVertexP2ui, "glVertexP2ui" );
            bindGLFunc( cast( void** )&glVertexP2uiv, "glVertexP2uiv" );
            bindGLFunc( cast( void** )&glVertexP3ui, "glVertexP3ui" );
            bindGLFunc( cast( void** )&glVertexP3uiv, "glVertexP3uiv" );
            bindGLFunc( cast( void** )&glVertexP4ui, "glVertexP4ui" );
            bindGLFunc( cast( void** )&glVertexP4uiv, "glVertexP4uiv" );
            bindGLFunc( cast( void** )&glTexCoordP1ui, "glTexCoordP1ui" );
            bindGLFunc( cast( void** )&glTexCoordP1uiv, "glTexCoordP1uiv" );
            bindGLFunc( cast( void** )&glTexCoordP2ui, "glTexCoordP2ui" );
            bindGLFunc( cast( void** )&glTexCoordP2uiv, "glTexCoordP2uiv" );
            bindGLFunc( cast( void** )&glTexCoordP3ui, "glTexCoordP3ui" );
            bindGLFunc( cast( void** )&glTexCoordP3uiv, "glTexCoordP3uiv" );
            bindGLFunc( cast( void** )&glTexCoordP4ui, "glTexCoordP4ui" );
            bindGLFunc( cast( void** )&glTexCoordP4uiv, "glTexCoordP4uiv" );
            bindGLFunc( cast( void** )&glMultiTexCoordP1ui, "glMultiTexCoordP1ui" );
            bindGLFunc( cast( void** )&glMultiTexCoordP1uiv, "glMultiTexCoordP1uiv" );
            bindGLFunc( cast( void** )&glMultiTexCoordP2ui, "glMultiTexCoordP2ui" );
            bindGLFunc( cast( void** )&glMultiTexCoordP2uiv, "glMultiTexCoordP2uiv" );
            bindGLFunc( cast( void** )&glMultiTexCoordP3ui, "glMultiTexCoordP3ui" );
            bindGLFunc( cast( void** )&glMultiTexCoordP3uiv, "glMultiTexCoordP3uiv" );
            bindGLFunc( cast( void** )&glMultiTexCoordP4ui, "glMultiTexCoordP4ui" );
            bindGLFunc( cast( void** )&glMultiTexCoordP4uiv, "glMultiTexCoordP4uiv" );
            bindGLFunc( cast( void** )&glNormalP3ui, "glNormalP3ui" );
            bindGLFunc( cast( void** )&glNormalP3uiv, "glNormalP3uiv" );
            bindGLFunc( cast( void** )&glColorP3ui, "glColorP3ui" );
            bindGLFunc( cast( void** )&glColorP3uiv, "glColorP3uiv" );
            bindGLFunc( cast( void** )&glColorP4ui, "glColorP4ui" );
            bindGLFunc( cast( void** )&glColorP4uiv, "glColorP4uiv" );
            bindGLFunc( cast( void** )&glSecondaryColorP3ui, "glSecondaryColorP3ui" );
            bindGLFunc( cast( void** )&glSecondaryColorP3uiv, "glSecondaryColorP3uiv" );
        }
        bindGLFunc( cast( void** )&glVertexAttribP1ui, "glVertexAttribP1ui" );
        bindGLFunc( cast( void** )&glVertexAttribP1uiv, "glVertexAttribP1uiv" );
        bindGLFunc( cast( void** )&glVertexAttribP2ui, "glVertexAttribP2ui" );
        bindGLFunc( cast( void** )&glVertexAttribP2uiv, "glVertexAttribP2uiv" );
        bindGLFunc( cast( void** )&glVertexAttribP3ui, "glVertexAttribP3ui" );
        bindGLFunc( cast( void** )&glVertexAttribP3uiv, "glVertexAttribP3uiv" );
        bindGLFunc( cast( void** )&glVertexAttribP4ui, "glVertexAttribP4ui" );
        bindGLFunc( cast( void** )&glVertexAttribP4uiv, "glVertexAttribP4uiv" );
        _ARB_vertex_type_2_10_10_10_rev = true;
    } catch( Exception e ) {
        _ARB_vertex_type_2_10_10_10_rev = false;
        if( doThrow ) throw e;
    }
}

// ARB_draw_indirect
extern( System ) nothrow {
    alias da_glDrawArraysIndirect = void function( GLenum, const( GLvoid )* );
    alias da_glDrawElementsIndirect = void function( GLenum, GLenum, const( GLvoid )* );
}

__gshared {
    da_glDrawArraysIndirect glDrawArraysIndirect;
    da_glDrawElementsIndirect glDrawElementsIndirect;
}

private __gshared bool _ARB_draw_indirect;
bool ARB_draw_indirect() @property { return _ARB_draw_indirect; }
package void load_ARB_draw_indirect( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glDrawArraysIndirect, "glDrawArraysIndirect" );
        bindGLFunc( cast( void** )&glDrawElementsIndirect, "glDrawElementsIndirect" );
        _ARB_draw_indirect = true;
    } catch( Exception e ) {
        _ARB_draw_indirect = false;
        if( doThrow ) throw e;
    }
}

// ARB_gpu_shader_fp64
extern( System ) nothrow {
    alias da_glUniform1d = void function( GLint, GLdouble );
    alias da_glUniform2d = void function( GLint, GLdouble, GLdouble );
    alias da_glUniform3d = void function( GLint, GLdouble, GLdouble, GLdouble );
    alias da_glUniform4d = void function( GLint, GLdouble, GLdouble, GLdouble, GLdouble );
    alias da_glUniform1dv = void function( GLint, GLsizei, const( GLdouble )* );
    alias da_glUniform2dv = void function( GLint, GLsizei, const( GLdouble )* );
    alias da_glUniform3dv = void function( GLint, GLsizei, const( GLdouble )* );
    alias da_glUniform4dv = void function( GLint, GLsizei, const( GLdouble )* );
    alias da_glUniformMatrix2dv = void function( GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glUniformMatrix3dv = void function( GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glUniformMatrix4dv = void function( GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glUniformMatrix2x3dv = void function( GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glUniformMatrix2x4dv = void function( GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glUniformMatrix3x2dv = void function( GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glUniformMatrix3x4dv = void function( GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glUniformMatrix4x2dv = void function( GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glUniformMatrix4x3dv = void function( GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glGetUniformdv = void function( GLuint, GLint, GLdouble* );
}

__gshared {
    da_glUniform1d glUniform1d;
    da_glUniform2d glUniform2d;
    da_glUniform3d glUniform3d;
    da_glUniform4d glUniform4d;
    da_glUniform1dv glUniform1dv;
    da_glUniform2dv glUniform2dv;
    da_glUniform3dv glUniform3dv;
    da_glUniform4dv glUniform4dv;
    da_glUniformMatrix2dv glUniformMatrix2dv;
    da_glUniformMatrix3dv glUniformMatrix3dv;
    da_glUniformMatrix4dv glUniformMatrix4dv;
    da_glUniformMatrix2x3dv glUniformMatrix2x3dv;
    da_glUniformMatrix2x4dv glUniformMatrix2x4dv;
    da_glUniformMatrix3x2dv glUniformMatrix3x2dv;
    da_glUniformMatrix3x4dv glUniformMatrix3x4dv;
    da_glUniformMatrix4x2dv glUniformMatrix4x2dv;
    da_glUniformMatrix4x3dv glUniformMatrix4x3dv;
    da_glGetUniformdv glGetUniformdv;
}

private __gshared bool _ARB_gpu_shader_fp64;
bool ARB_gpu_shader_fp64() @property { return _ARB_gpu_shader_fp64; }
package void load_ARB_gpu_shader_fp64( bool doThrow = false ) {
    try
    {
        bindGLFunc( cast( void** )&glUniform1d, "glUniform1d" );
        bindGLFunc( cast( void** )&glUniform2d, "glUniform2d" );
        bindGLFunc( cast( void** )&glUniform3d, "glUniform3d" );
        bindGLFunc( cast( void** )&glUniform4d, "glUniform4d" );
        bindGLFunc( cast( void** )&glUniform1dv, "glUniform1dv" );
        bindGLFunc( cast( void** )&glUniform2dv, "glUniform2dv" );
        bindGLFunc( cast( void** )&glUniform3dv, "glUniform3dv" );
        bindGLFunc( cast( void** )&glUniform4dv, "glUniform4dv" );
        bindGLFunc( cast( void** )&glUniformMatrix2dv, "glUniformMatrix2dv" );
        bindGLFunc( cast( void** )&glUniformMatrix3dv, "glUniformMatrix3dv" );
        bindGLFunc( cast( void** )&glUniformMatrix4dv, "glUniformMatrix4dv" );
        bindGLFunc( cast( void** )&glUniformMatrix2x3dv, "glUniformMatrix2x3dv" );
        bindGLFunc( cast( void** )&glUniformMatrix2x4dv, "glUniformMatrix2x4dv" );
        bindGLFunc( cast( void** )&glUniformMatrix3x2dv, "glUniformMatrix3x2dv" );
        bindGLFunc( cast( void** )&glUniformMatrix3x4dv, "glUniformMatrix3x4dv" );
        bindGLFunc( cast( void** )&glUniformMatrix4x2dv, "glUniformMatrix4x2dv" );
        bindGLFunc( cast( void** )&glUniformMatrix4x3dv, "glUniformMatrix4x3dv" );
        _ARB_gpu_shader_fp64 = true;
    } catch( Exception e ) {
        _ARB_gpu_shader_fp64 = false;
        if( doThrow ) throw e;
    }
}

// ARB_shader_subroutine
extern( System ) nothrow {
    alias da_glGetSubroutineUniformLocation = GLint function( GLuint, GLenum, const( GLchar )* );
    alias da_glGetSubroutineIndex = GLuint function( GLuint, GLenum, const( GLchar )* );
    alias da_glGetActiveSubroutineUniformiv = void function( GLuint, GLenum, GLuint, GLenum, GLint* );
    alias da_glGetActiveSubroutineUniformName = void function( GLuint, GLenum, GLuint, GLsizei, GLsizei*, GLchar* );
    alias da_glGetActiveSubroutineName = void function( GLuint, GLenum, GLuint, GLsizei, GLsizei*, GLchar* );
    alias da_glUniformSubroutinesuiv = void function( GLenum, GLsizei, const( GLuint )* );
    alias da_glGetUniformSubroutineuiv = void function( GLenum, GLint, GLuint* );
    alias da_glGetProgramStageiv = void function( GLuint, GLenum, GLenum, GLint* );
}

__gshared {
    da_glGetSubroutineUniformLocation glGetSubroutineUniformLocation;
    da_glGetSubroutineIndex glGetSubroutineIndex;
    da_glGetActiveSubroutineUniformiv glGetActiveSubroutineUniformiv;
    da_glGetActiveSubroutineUniformName glGetActiveSubroutineUniformName;
    da_glGetActiveSubroutineName glGetActiveSubroutineName;
    da_glUniformSubroutinesuiv glUniformSubroutinesuiv;
    da_glGetUniformSubroutineuiv glGetUniformSubroutineuiv;
    da_glGetProgramStageiv glGetProgramStageiv;
}

private __gshared bool _ARB_shader_subroutine;
bool ARB_shader_subroutine() @property { return _ARB_shader_subroutine; }
package void load_ARB_shader_subroutine( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glGetSubroutineUniformLocation, "glGetSubroutineUniformLocation" );
        bindGLFunc( cast( void** )&glGetSubroutineIndex, "glGetSubroutineIndex" );
        bindGLFunc( cast( void** )&glGetActiveSubroutineUniformiv, "glGetActiveSubroutineUniformiv" );
        bindGLFunc( cast( void** )&glGetActiveSubroutineUniformName, "glGetActiveSubroutineUniformName" );
        bindGLFunc( cast( void** )&glGetActiveSubroutineName, "glGetActiveSubroutineName" );
        bindGLFunc( cast( void** )&glUniformSubroutinesuiv, "glUniformSubroutinesuiv" );
        bindGLFunc( cast( void** )&glGetUniformSubroutineuiv, "glGetUniformSubroutineuiv" );
        bindGLFunc( cast( void** )&glGetProgramStageiv, "glGetProgramStageiv" );
        _ARB_shader_subroutine = true;
    } catch( Exception e ) {
        _ARB_shader_subroutine = false;
        if( doThrow ) throw e;
    }
}

// ARB_tessellation_shader
extern( System ) nothrow {
    alias da_glPatchParameteri = void function( GLenum, GLint );
    alias da_glPatchParameterfv = void function( GLenum, const( GLfloat )* );
}
__gshared da_glPatchParameteri glPatchParameteri;
__gshared da_glPatchParameterfv glPatchParameterfv;

private __gshared bool _ARB_tessellation_shader;
bool ARB_tessellation_shader() @property { return _ARB_tessellation_shader; }
package void load_ARB_tessellation_shader( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glPatchParameteri, "glPatchParameteri" );
        bindGLFunc( cast( void** )&glPatchParameterfv, "glPatchParameterfv" );
        _ARB_tessellation_shader = true;
    } catch( Exception e ) {
        _ARB_tessellation_shader = false;
        if( doThrow ) throw e;
    }
}

// ARB_transform_feedback2
extern( System ) nothrow {
    alias da_glBindTransformFeedback = void function( GLenum, GLuint );
    alias da_glDeleteTransformFeedbacks = void function( GLsizei, const( GLuint )* );
    alias da_glGenTransformFeedbacks = void function( GLsizei, GLuint* );
    alias da_glIsTransformFeedback = GLboolean function( GLuint );
    alias da_glPauseTransformFeedback = void function();
    alias da_glResumeTransformFeedback = void function();
    alias da_glDrawTransformFeedback = void function( GLenum, GLuint );
}

__gshared {
    da_glBindTransformFeedback glBindTransformFeedback;
    da_glDeleteTransformFeedbacks glDeleteTransformFeedbacks;
    da_glGenTransformFeedbacks glGenTransformFeedbacks;
    da_glIsTransformFeedback glIsTransformFeedback;
    da_glPauseTransformFeedback glPauseTransformFeedback;
    da_glResumeTransformFeedback glResumeTransformFeedback;
    da_glDrawTransformFeedback glDrawTransformFeedback;
}

private __gshared bool _ARB_transform_feedback2;
bool ARB_transform_feedback2() { return _ARB_transform_feedback2; }
void load_ARB_transform_feedback2( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glBindTransformFeedback, "glBindTransformFeedback" );
        bindGLFunc( cast( void** )&glDeleteTransformFeedbacks, "glDeleteTransformFeedbacks" );
        bindGLFunc( cast( void** )&glGenTransformFeedbacks, "glGenTransformFeedbacks" );
        bindGLFunc( cast( void** )&glIsTransformFeedback, "glIsTransformFeedback" );
        bindGLFunc( cast( void** )&glPauseTransformFeedback, "glPauseTransformFeedback" );
        bindGLFunc( cast( void** )&glResumeTransformFeedback, "glResumeTransformFeedback" );
        bindGLFunc( cast( void** )&glDrawTransformFeedback, "glDrawTransformFeedback" );
        _ARB_transform_feedback2 = true;
    } catch( Exception e ) {
        _ARB_transform_feedback2 = false;
        if( doThrow ) throw e;
    }
}

// ARB_transform_feedback3
extern( System ) nothrow {
    alias da_glDrawTransformFeedbackStream = void function( GLenum, GLuint, GLuint );
    alias da_glBeginQueryIndexed = void function( GLenum, GLuint, GLuint );
    alias da_glEndQueryIndexed = void function( GLenum, GLuint );
    alias da_glGetQueryIndexediv = void function( GLenum, GLuint, GLenum, GLint* );
}

__gshared {
    da_glDrawTransformFeedbackStream glDrawTransformFeedbackStream;
    da_glBeginQueryIndexed glBeginQueryIndexed;
    da_glEndQueryIndexed glEndQueryIndexed;
    da_glGetQueryIndexediv glGetQueryIndexediv;
}

private __gshared bool _ARB_transform_feedback3;
bool ARB_transform_feedback3() { return _ARB_transform_feedback3; }
package void load_ARB_transform_feedback3( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glDrawTransformFeedbackStream, "glDrawTransformFeedbackStream" );
        bindGLFunc( cast( void** )&glBeginQueryIndexed, "glBeginQueryIndexed" );
        bindGLFunc( cast( void** )&glEndQueryIndexed, "glEndQueryIndexed" );
        bindGLFunc( cast( void** )&glGetQueryIndexediv, "glGetQueryIndexediv" );
        _ARB_transform_feedback3 = true;
    } catch( Exception e ) {
        _ARB_transform_feedback3 = false;
        if( doThrow ) throw e;
    }
}

// ARB_ES2_compatibility
extern( System ) nothrow {
    alias da_glReleaseShaderCompiler = void function();
    alias da_glShaderBinary = void function( GLsizei, const( GLuint )*, GLenum, const( GLvoid )*, GLsizei );
    alias da_glGetShaderPrecisionFormat = void function( GLenum, GLenum, GLint*, GLint* );
    alias da_glDepthRangef = void function( GLclampf, GLclampf );
    alias da_glClearDepthf = void function( GLclampf );
}

__gshared {
    da_glReleaseShaderCompiler glReleaseShaderCompiler;
    da_glShaderBinary glShaderBinary;
    da_glGetShaderPrecisionFormat glGetShaderPrecisionFormat;
    da_glDepthRangef glDepthRangef;
    da_glClearDepthf glClearDepthf;
}

private __gshared bool _ARB_ES2_compatibility;
bool ARB_ES2_compatibility() @property { return _ARB_ES2_compatibility; }
package void load_ARB_ES2_compatibility( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glReleaseShaderCompiler, "glReleaseShaderCompiler" );
        bindGLFunc( cast( void** )&glShaderBinary, "glShaderBinary" );
        bindGLFunc( cast( void** )&glGetShaderPrecisionFormat, "glGetShaderPrecisionFormat" );
        bindGLFunc( cast( void** )&glDepthRangef, "glDepthRangef" );
        bindGLFunc( cast( void** )&glClearDepthf, "glClearDepthf" );
        _ARB_ES2_compatibility = true;
    } catch( Exception e ) {
        _ARB_ES2_compatibility = false;
        if( doThrow ) throw e;
    }
}

// ARB_get_program_binary
extern( System ) nothrow {
    alias da_glGetProgramBinary = void function( GLuint, GLsizei, GLsizei*, GLenum*, GLvoid* );
    alias da_glProgramBinary = void function( GLuint, GLenum, const( GLvoid )*, GLsizei );
    alias da_glProgramParameteri = void function( GLuint, GLenum, GLint );
}

__gshared {
    da_glGetProgramBinary glGetProgramBinary;
    da_glProgramBinary glProgramBinary;
    da_glProgramParameteri glProgramParameteri;
}

private __gshared bool _ARB_get_program_binary;
bool ARB_get_program_binary() @property { return _ARB_get_program_binary; }
package void load_ARB_get_program_binary( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glGetProgramBinary, "glGetProgramBinary" );
        bindGLFunc( cast( void** )&glProgramBinary, "glProgramBinary" );
        bindGLFunc( cast( void** )&glProgramParameteri, "glProgramParameteri" );
        _ARB_get_program_binary = true;
    } catch( Exception e ) {
        _ARB_get_program_binary = false;
        if( doThrow ) throw e;
    }
}

// ARB_separate_shader_objects
extern( System ) nothrow {
    alias da_glUseProgramStages = void function( GLuint, GLbitfield, GLuint );
    alias da_glActiveShaderProgram = void function( GLuint, GLuint );
    alias da_glCreateShaderProgramv = GLuint function( GLenum, GLsizei, const( GLchar* )* );
    alias da_glBindProgramPipeline = void function( GLuint );
    alias da_glDeleteProgramPipelines = void function( GLsizei, const( GLuint )* );
    alias da_glGenProgramPipelines = void function( GLsizei, GLuint* );
    alias da_glIsProgramPipeline = GLboolean function( GLuint );
    alias da_glGetProgramPipelineiv = void function( GLuint, GLenum, GLint* );
    alias da_glProgramUniform1i = void function( GLuint, GLint, GLint );
    alias da_glProgramUniform1iv = void function( GLuint, GLint, GLsizei, const( GLint )* );
    alias da_glProgramUniform1f = void function( GLuint, GLint, GLfloat );
    alias da_glProgramUniform1fv = void function( GLuint, GLint, GLsizei, const( GLfloat )* );
    alias da_glProgramUniform1d = void function( GLuint, GLint, GLdouble );
    alias da_glProgramUniform1dv = void function( GLuint, GLint, GLsizei, const( GLdouble )* );
    alias da_glProgramUniform1ui = void function( GLuint, GLint, GLuint );
    alias da_glProgramUniform1uiv = void function( GLuint, GLint, GLsizei, const( GLuint )* );
    alias da_glProgramUniform2i = void function( GLuint, GLint, GLint, GLint );
    alias da_glProgramUniform2iv = void function( GLuint, GLint, GLsizei, const( GLint )* );
    alias da_glProgramUniform2f = void function( GLuint, GLint, GLfloat, GLfloat );
    alias da_glProgramUniform2fv = void function( GLuint, GLint, GLsizei, const( GLfloat )* );
    alias da_glProgramUniform2d = void function( GLuint, GLint, GLdouble, GLdouble );
    alias da_glProgramUniform2dv = void function( GLuint, GLint, GLsizei, const( GLdouble )* );
    alias da_glProgramUniform2ui = void function( GLuint, GLint, GLuint, GLuint );
    alias da_glProgramUniform2uiv = void function( GLuint, GLint, GLsizei, const( GLuint )* );
    alias da_glProgramUniform3i = void function( GLuint, GLint, GLint, GLint, GLint );
    alias da_glProgramUniform3iv = void function( GLuint, GLint, GLsizei, const( GLint )* );
    alias da_glProgramUniform3f = void function( GLuint, GLint, GLfloat, GLfloat, GLfloat );
    alias da_glProgramUniform3fv = void function( GLuint, GLint, GLsizei, const( GLfloat )* );
    alias da_glProgramUniform3d = void function( GLuint, GLint, GLdouble, GLdouble, GLdouble );
    alias da_glProgramUniform3dv = void function( GLuint, GLint, GLsizei, const( GLdouble )* );
    alias da_glProgramUniform3ui = void function( GLuint, GLint, GLuint, GLuint, GLuint );
    alias da_glProgramUniform3uiv = void function( GLuint, GLint, GLsizei, const( GLuint )* );
    alias da_glProgramUniform4i = void function( GLuint, GLint, GLint, GLint, GLint, GLint );
    alias da_glProgramUniform4iv = void function( GLuint, GLint, GLsizei, const( GLint )* );
    alias da_glProgramUniform4f = void function( GLuint, GLint, GLfloat, GLfloat, GLfloat, GLfloat );
    alias da_glProgramUniform4fv = void function( GLuint, GLint, GLsizei, const( GLfloat )* );
    alias da_glProgramUniform4d = void function( GLuint, GLint, GLdouble, GLdouble, GLdouble, GLdouble );
    alias da_glProgramUniform4dv = void function( GLuint, GLint, GLsizei, const( GLdouble )* );
    alias da_glProgramUniform4ui = void function( GLuint, GLint, GLuint, GLuint, GLuint, GLuint );
    alias da_glProgramUniform4uiv = void function( GLuint, GLint, GLsizei, const( GLuint )* );
    alias da_glProgramUniformMatrix2fv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLfloat )* );
    alias da_glProgramUniformMatrix3fv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLfloat )* );
    alias da_glProgramUniformMatrix4fv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLfloat )* );
    alias da_glProgramUniformMatrix2dv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glProgramUniformMatrix3dv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glProgramUniformMatrix4dv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glProgramUniformMatrix2x3fv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLfloat )* );
    alias da_glProgramUniformMatrix3x2fv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLfloat )* );
    alias da_glProgramUniformMatrix2x4fv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLfloat )* );
    alias da_glProgramUniformMatrix4x2fv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLfloat )* );
    alias da_glProgramUniformMatrix3x4fv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLfloat )* );
    alias da_glProgramUniformMatrix4x3fv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLfloat )* );
    alias da_glProgramUniformMatrix2x3dv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glProgramUniformMatrix3x2dv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glProgramUniformMatrix2x4dv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glProgramUniformMatrix4x2dv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glProgramUniformMatrix3x4dv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glProgramUniformMatrix4x3dv = void function( GLuint, GLint, GLsizei, GLboolean, const( GLdouble )* );
    alias da_glValidateProgramPipeline = void function( GLuint );
    alias da_glGetProgramPipelineInfoLog = void function( GLuint, GLsizei, GLsizei*, GLchar* );
}

__gshared {
    da_glUseProgramStages glUseProgramStages;
    da_glActiveShaderProgram glActiveShaderProgram;
    da_glCreateShaderProgramv glCreateShaderProgramv;
    da_glBindProgramPipeline glBindProgramPipeline;
    da_glDeleteProgramPipelines glDeleteProgramPipelines;
    da_glGenProgramPipelines glGenProgramPipelines;
    da_glIsProgramPipeline glIsProgramPipeline;
    da_glGetProgramPipelineiv glGetProgramPipelineiv;
    da_glProgramUniform1i glProgramUniform1i;
    da_glProgramUniform1iv glProgramUniform1iv;
    da_glProgramUniform1f glProgramUniform1f;
    da_glProgramUniform1fv glProgramUniform1fv;
    da_glProgramUniform1d glProgramUniform1d;
    da_glProgramUniform1dv glProgramUniform1dv;
    da_glProgramUniform1ui glProgramUniform1ui;
    da_glProgramUniform1uiv glProgramUniform1uiv;
    da_glProgramUniform2i glProgramUniform2i;
    da_glProgramUniform2iv glProgramUniform2iv;
    da_glProgramUniform2f glProgramUniform2f;
    da_glProgramUniform2fv glProgramUniform2fv;
    da_glProgramUniform2d glProgramUniform2d;
    da_glProgramUniform2dv glProgramUniform2dv;
    da_glProgramUniform2ui glProgramUniform2ui;
    da_glProgramUniform2uiv glProgramUniform2uiv;
    da_glProgramUniform3i glProgramUniform3i;
    da_glProgramUniform3iv glProgramUniform3iv;
    da_glProgramUniform3f glProgramUniform3f;
    da_glProgramUniform3fv glProgramUniform3fv;
    da_glProgramUniform3d glProgramUniform3d;
    da_glProgramUniform3dv glProgramUniform3dv;
    da_glProgramUniform3ui glProgramUniform3ui;
    da_glProgramUniform3uiv glProgramUniform3uiv;
    da_glProgramUniform4i glProgramUniform4i;
    da_glProgramUniform4iv glProgramUniform4iv;
    da_glProgramUniform4f glProgramUniform4f;
    da_glProgramUniform4fv glProgramUniform4fv;
    da_glProgramUniform4d glProgramUniform4d;
    da_glProgramUniform4dv glProgramUniform4dv;
    da_glProgramUniform4ui glProgramUniform4ui;
    da_glProgramUniform4uiv glProgramUniform4uiv;
    da_glProgramUniformMatrix2fv glProgramUniformMatrix2fv;
    da_glProgramUniformMatrix3fv glProgramUniformMatrix3fv;
    da_glProgramUniformMatrix4fv glProgramUniformMatrix4fv;
    da_glProgramUniformMatrix2dv glProgramUniformMatrix2dv;
    da_glProgramUniformMatrix3dv glProgramUniformMatrix3dv;
    da_glProgramUniformMatrix4dv glProgramUniformMatrix4dv;
    da_glProgramUniformMatrix2x3fv glProgramUniformMatrix2x3fv;
    da_glProgramUniformMatrix3x2fv glProgramUniformMatrix3x2fv;
    da_glProgramUniformMatrix2x4fv glProgramUniformMatrix2x4fv;
    da_glProgramUniformMatrix4x2fv glProgramUniformMatrix4x2fv;
    da_glProgramUniformMatrix3x4fv glProgramUniformMatrix3x4fv;
    da_glProgramUniformMatrix4x3fv glProgramUniformMatrix4x3fv;
    da_glProgramUniformMatrix2x3dv glProgramUniformMatrix2x3dv;
    da_glProgramUniformMatrix3x2dv glProgramUniformMatrix3x2dv;
    da_glProgramUniformMatrix2x4dv glProgramUniformMatrix2x4dv;
    da_glProgramUniformMatrix4x2dv glProgramUniformMatrix4x2dv;
    da_glProgramUniformMatrix3x4dv glProgramUniformMatrix3x4dv;
    da_glProgramUniformMatrix4x3dv glProgramUniformMatrix4x3dv;
    da_glValidateProgramPipeline glValidateProgramPipeline;
    da_glGetProgramPipelineInfoLog glGetProgramPipelineInfoLog;
}

private __gshared bool _ARB_separate_shader_objects;
bool ARB_separate_shader_objects() @property { return _ARB_separate_shader_objects; }
package void load_ARB_separate_shader_objects( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glUseProgramStages, "glUseProgramStages" );
        bindGLFunc( cast( void** )&glActiveShaderProgram, "glActiveShaderProgram" );
        bindGLFunc( cast( void** )&glCreateShaderProgramv, "glCreateShaderProgramv" );
        bindGLFunc( cast( void** )&glBindProgramPipeline, "glBindProgramPipeline" );
        bindGLFunc( cast( void** )&glDeleteProgramPipelines, "glDeleteProgramPipelines" );
        bindGLFunc( cast( void** )&glGenProgramPipelines, "glGenProgramPipelines" );
        bindGLFunc( cast( void** )&glIsProgramPipeline, "glIsProgramPipeline" );
        bindGLFunc( cast( void** )&glGetProgramPipelineiv, "glGetProgramPipelineiv" );
        bindGLFunc( cast( void** )&glProgramUniform1i, "glProgramUniform1i" );
        bindGLFunc( cast( void** )&glProgramUniform1iv, "glProgramUniform1iv" );
        bindGLFunc( cast( void** )&glProgramUniform1f, "glProgramUniform1f" );
        bindGLFunc( cast( void** )&glProgramUniform1fv, "glProgramUniform1fv" );
        bindGLFunc( cast( void** )&glProgramUniform1d, "glProgramUniform1d" );
        bindGLFunc( cast( void** )&glProgramUniform1dv, "glProgramUniform1dv" );
        bindGLFunc( cast( void** )&glProgramUniform1ui, "glProgramUniform1ui" );
        bindGLFunc( cast( void** )&glProgramUniform1uiv, "glProgramUniform1uiv" );
        bindGLFunc( cast( void** )&glProgramUniform2i, "glProgramUniform2i" );
        bindGLFunc( cast( void** )&glProgramUniform2iv, "glProgramUniform2iv" );
        bindGLFunc( cast( void** )&glProgramUniform2f, "glProgramUniform2f" );
        bindGLFunc( cast( void** )&glProgramUniform2fv, "glProgramUniform2fv" );
        bindGLFunc( cast( void** )&glProgramUniform2d, "glProgramUniform2d" );
        bindGLFunc( cast( void** )&glProgramUniform2dv, "glProgramUniform2dv" );
        bindGLFunc( cast( void** )&glProgramUniform2ui, "glProgramUniform2ui" );
        bindGLFunc( cast( void** )&glProgramUniform2uiv, "glProgramUniform2uiv" );
        bindGLFunc( cast( void** )&glProgramUniform3i, "glProgramUniform3i" );
        bindGLFunc( cast( void** )&glProgramUniform3iv, "glProgramUniform3iv" );
        bindGLFunc( cast( void** )&glProgramUniform3f, "glProgramUniform3f" );
        bindGLFunc( cast( void** )&glProgramUniform3fv, "glProgramUniform3fv" );
        bindGLFunc( cast( void** )&glProgramUniform3d, "glProgramUniform3d" );
        bindGLFunc( cast( void** )&glProgramUniform3dv, "glProgramUniform3dv" );
        bindGLFunc( cast( void** )&glProgramUniform3ui, "glProgramUniform3ui" );
        bindGLFunc( cast( void** )&glProgramUniform3uiv, "glProgramUniform3uiv" );
        bindGLFunc( cast( void** )&glProgramUniform4i, "glProgramUniform4i" );
        bindGLFunc( cast( void** )&glProgramUniform4iv, "glProgramUniform4iv" );
        bindGLFunc( cast( void** )&glProgramUniform4f, "glProgramUniform4f" );
        bindGLFunc( cast( void** )&glProgramUniform4fv, "glProgramUniform4fv" );
        bindGLFunc( cast( void** )&glProgramUniform4d, "glProgramUniform4d" );
        bindGLFunc( cast( void** )&glProgramUniform4dv, "glProgramUniform4dv" );
        bindGLFunc( cast( void** )&glProgramUniform4ui, "glProgramUniform4ui" );
        bindGLFunc( cast( void** )&glProgramUniform4uiv, "glProgramUniform4uiv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix2fv, "glProgramUniformMatrix2fv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix3fv, "glProgramUniformMatrix3fv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix4fv, "glProgramUniformMatrix4fv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix2dv, "glProgramUniformMatrix2dv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix3dv, "glProgramUniformMatrix3dv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix4dv, "glProgramUniformMatrix4dv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix2x3fv, "glProgramUniformMatrix2x3fv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix3x2fv, "glProgramUniformMatrix3x2fv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix2x4fv, "glProgramUniformMatrix2x4fv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix4x2fv, "glProgramUniformMatrix4x2fv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix3x4fv, "glProgramUniformMatrix3x4fv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix4x3fv, "glProgramUniformMatrix4x3fv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix2x3dv, "glProgramUniformMatrix2x3dv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix3x2dv, "glProgramUniformMatrix3x2dv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix2x4dv, "glProgramUniformMatrix2x4dv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix4x2dv, "glProgramUniformMatrix4x2dv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix3x4dv, "glProgramUniformMatrix3x4dv" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix4x3dv, "glProgramUniformMatrix4x3dv" );
        bindGLFunc( cast( void** )&glValidateProgramPipeline, "glValidateProgramPipeline" );
        bindGLFunc( cast( void** )&glGetProgramPipelineInfoLog, "glGetProgramPipelineInfoLog" );
        _ARB_separate_shader_objects = true;
    } catch( Exception e ) {
        _ARB_separate_shader_objects = false;
        if( doThrow ) throw e;
    }
}

// ARB_vertex_attrib_64bit
extern( System ) nothrow {
    alias da_glVertexAttribL1d = void function( GLuint, GLdouble );
    alias da_glVertexAttribL2d = void function( GLuint, GLdouble, GLdouble );
    alias da_glVertexAttribL3d = void function( GLuint, GLdouble, GLdouble, GLdouble );
    alias da_glVertexAttribL4d = void function( GLuint, GLdouble, GLdouble, GLdouble, GLdouble );
    alias da_glVertexAttribL1dv = void function( GLuint, const( GLdouble )* );
    alias da_glVertexAttribL2dv = void function( GLuint, const( GLdouble )* );
    alias da_glVertexAttribL3dv = void function( GLuint, const( GLdouble )* );
    alias da_glVertexAttribL4dv = void function( GLuint, const( GLdouble )* );
    alias da_glVertexAttribLPointer = void function( GLuint, GLint, GLenum, GLsizei, const( GLvoid )* );
    alias da_glGetVertexAttribLdv = void function( GLuint, GLenum, GLdouble* );
}

__gshared {
    da_glVertexAttribL1d glVertexAttribL1d;
    da_glVertexAttribL2d glVertexAttribL2d;
    da_glVertexAttribL3d glVertexAttribL3d;
    da_glVertexAttribL4d glVertexAttribL4d;
    da_glVertexAttribL1dv glVertexAttribL1dv;
    da_glVertexAttribL2dv glVertexAttribL2dv;
    da_glVertexAttribL3dv glVertexAttribL3dv;
    da_glVertexAttribL4dv glVertexAttribL4dv;
    da_glVertexAttribLPointer glVertexAttribLPointer;
    da_glGetVertexAttribLdv glGetVertexAttribLdv;
}

private __gshared bool _ARB_vertex_attrib_64bit;
bool ARB_vertex_attrib_64bit() @property { return _ARB_vertex_attrib_64bit; }
package void load_ARB_vertex_attrib_64bit( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glVertexAttribL1d, "glVertexAttribL1d" );
        bindGLFunc( cast( void** )&glVertexAttribL2d, "glVertexAttribL2d" );
        bindGLFunc( cast( void** )&glVertexAttribL3d, "glVertexAttribL3d" );
        bindGLFunc( cast( void** )&glVertexAttribL4d, "glVertexAttribL4d" );
        bindGLFunc( cast( void** )&glVertexAttribL1dv, "glVertexAttribL1dv" );
        bindGLFunc( cast( void** )&glVertexAttribL2dv, "glVertexAttribL2dv" );
        bindGLFunc( cast( void** )&glVertexAttribL3dv, "glVertexAttribL3dv" );
        bindGLFunc( cast( void** )&glVertexAttribL4dv, "glVertexAttribL4dv" );
        bindGLFunc( cast( void** )&glVertexAttribLPointer, "glVertexAttribLPointer" );
        bindGLFunc( cast( void** )&glGetVertexAttribLdv, "glGetVertexAttribLdv" );
        _ARB_vertex_attrib_64bit = true;
    } catch( Exception e ) {
        _ARB_vertex_attrib_64bit = false;
        if( doThrow ) throw e;
    }
}

// ARB_viewport_array
extern( System ) nothrow {
    alias da_glViewportArrayv = void function( GLuint, GLsizei, const( GLfloat )* );
    alias da_glViewportIndexedf = void function( GLuint, GLfloat, GLfloat, GLfloat, GLfloat );
    alias da_glViewportIndexedfv = void function( GLuint, const( GLfloat )* );
    alias da_glScissorArrayv = void function( GLuint, GLsizei, const( GLint )* );
    alias da_glScissorIndexed = void function( GLuint, GLint, GLint, GLsizei, GLsizei );
    alias da_glScissorIndexedv = void function( GLuint, const( GLint )* );
    alias da_glDepthRangeArrayv = void function( GLuint, GLsizei, const( GLclampd )* );
    alias da_glDepthRangeIndexed = void function( GLuint, GLclampd, GLclampd );
    alias da_glGetFloati_v = void function( GLenum, GLuint, GLfloat* );
    alias da_glGetDoublei_v = void function( GLenum, GLuint, GLdouble* );
}

__gshared {
    da_glViewportArrayv glViewportArrayv;
    da_glViewportIndexedf glViewportIndexedf;
    da_glViewportIndexedfv glViewportIndexedfv;
    da_glScissorArrayv glScissorArrayv;
    da_glScissorIndexed glScissorIndexed;
    da_glScissorIndexedv glScissorIndexedv;
    da_glDepthRangeArrayv glDepthRangeArrayv;
    da_glDepthRangeIndexed glDepthRangeIndexed;
    da_glGetFloati_v glGetFloati_v;
    da_glGetDoublei_v glGetDoublei_v;
}

private __gshared bool _ARB_viewport_array;
bool ARB_viewport_array() @property { return _ARB_viewport_array; }
package void load_ARB_viewport_array( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glViewportArrayv, "glViewportArrayv" );
        bindGLFunc( cast( void** )&glViewportIndexedf, "glViewportIndexedf" );
        bindGLFunc( cast( void** )&glViewportIndexedfv, "glViewportIndexedfv" );
        bindGLFunc( cast( void** )&glScissorArrayv, "glScissorArrayv" );
        bindGLFunc( cast( void** )&glScissorIndexed, "glScissorIndexed" );
        bindGLFunc( cast( void** )&glScissorIndexedv, "glScissorIndexedv" );
        bindGLFunc( cast( void** )&glDepthRangeArrayv, "glDepthRangeArrayv" );
        bindGLFunc( cast( void** )&glDepthRangeIndexed, "glDepthRangeIndexed" );
        bindGLFunc( cast( void** )&glGetFloati_v, "glGetFloati_v" );
        bindGLFunc( cast( void** )&glGetDoublei_v, "glGetDoublei_v" );
        _ARB_viewport_array = true;
    } catch( Exception e ) {
        _ARB_viewport_array = false;
        if( doThrow ) throw e;
    }
}

// ARB_cl_event
extern( System ) nothrow alias  da_glCreateSyncFromCLeventARB = GLsync function( _cl_context*, _cl_event*, GLbitfield );
__gshared da_glCreateSyncFromCLeventARB glCreateSyncFromCLeventARB;

private __gshared bool _ARB_cl_event;
bool ARB_cl_event() @property { return _ARB_cl_event; }
package void load_ARB_cl_event() {
    try {
        bindGLFunc( cast( void** )&glCreateSyncFromCLeventARB, "glCreateSyncFromCLeventARB" );
        _ARB_cl_event = true;
    } catch( Exception e ) {
        _ARB_cl_event = false;
    }
}

// ARB_debug_output
extern( System ) nothrow {
    alias da_glDebugMessageControlARB = void function( GLenum, GLenum, GLenum, GLsizei, const( GLuint )*, GLboolean );
    alias da_glDebugMessageInsertARB = void function( GLenum, GLenum, GLuint, GLenum, GLsizei, const( GLchar )* );
    alias da_glDebugMessageCallbackARB = void function( GLDEBUGPROCARB, const( GLvoid )* );
    alias da_glGetDebugMessageLogARB = void function( GLuint, GLsizei, GLenum*, GLenum*, GLuint*, GLenum*, GLsizei*, GLchar* );
}

__gshared {
    da_glDebugMessageControlARB glDebugMessageControlARB;
    da_glDebugMessageInsertARB glDebugMessageInsertARB;
    da_glDebugMessageCallbackARB glDebugMessageCallbackARB;
    da_glGetDebugMessageLogARB glGetDebugMessageLogARB;
}

private __gshared bool _ARB_debug_output;
bool ARB_debug_output() @property { return _ARB_debug_output; }
package void load_ARB_debug_output() {
    try {
        bindGLFunc( cast( void** )&glDebugMessageControlARB, "glDebugMessageControlARB" );
        bindGLFunc( cast( void** )&glDebugMessageInsertARB, "glDebugMessageInsertARB" );
        bindGLFunc( cast( void** )&glDebugMessageCallbackARB, "glDebugMessageCallbackARB" );
        bindGLFunc( cast( void** )&glGetDebugMessageLogARB, "glGetDebugMessageLogARB" );
        _ARB_debug_output = true;
    } catch( Exception e ) {
        _ARB_debug_output = false;
    }
}

// ARB_robustness
extern( System ) nothrow {
    alias da_glGetGraphicsResetStatusARB = GLenum function();
    alias da_glGetnMapdvARB = void function( GLenum, GLenum, GLsizei, GLdouble* );
    alias da_glGetnMapfvARB = void function( GLenum, GLenum, GLsizei, GLfloat* );
    alias da_glGetnMapivARB = void function( GLenum, GLenum, GLsizei, GLint* );
    alias da_glGetnPixelMapfvARB = void function( GLenum, GLsizei, GLfloat* );
    alias da_glGetnPixelMapuivARB = void function( GLenum, GLsizei, GLuint* );
    alias da_glGetnPixelMapusvARB = void function( GLenum, GLsizei, GLushort* );
    alias da_glGetnPolygonStippleARB = void function( GLsizei, GLubyte* );
    alias da_glGetnColorTableARB = void function( GLenum, GLenum, GLenum, GLsizei, GLvoid* );
    alias da_glGetnConvolutionFilterARB = void function( GLenum, GLenum, GLenum, GLsizei, GLvoid* );
    alias da_glGetnSeparableFilterARB = void function( GLenum, GLenum, GLenum, GLsizei, GLvoid*, GLsizei, GLvoid*, GLvoid* );
    alias da_glGetnHistogramARB = void function( GLenum, GLboolean, GLenum, GLenum, GLsizei, GLvoid* );
    alias da_glGetnMinmaxARB = void function( GLenum, GLboolean, GLenum, GLenum, GLsizei, GLvoid* );
    alias da_glGetnTexImageARB = void function( GLenum, GLint, GLenum, GLenum, GLsizei, GLvoid* );
    alias da_glReadnPixelsARB = void function( GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLsizei, GLvoid* );
    alias da_glGetnCompressedTexImageARB = void function( GLenum, GLint, GLsizei, GLvoid* );
    alias da_glGetnUniformfvARB = void function( GLuint, GLint, GLsizei, GLfloat* );
    alias da_glGetnUniformivARB = void function( GLuint, GLint, GLsizei, GLint* );
    alias da_glGetnUniformuivARB = void function( GLuint, GLint, GLsizei, GLuint* );
    alias da_glGetnUniformdvARB = void function( GLuint, GLint, GLsizei, GLdouble* );
}

__gshared {
    da_glGetGraphicsResetStatusARB glGetGraphicsResetStatusARB;
    da_glGetnMapdvARB glGetnMapdvARB;
    da_glGetnMapfvARB glGetnMapfvARB;
    da_glGetnMapivARB glGetnMapivARB;
    da_glGetnPixelMapfvARB glGetnPixelMapfvARB;
    da_glGetnPixelMapuivARB glGetnPixelMapuivARB;
    da_glGetnPixelMapusvARB glGetnPixelMapusvARB;
    da_glGetnPolygonStippleARB glGetnPolygonStippleARB;
    da_glGetnColorTableARB glGetnColorTableARB;
    da_glGetnConvolutionFilterARB glGetnConvolutionFilterARB;
    da_glGetnSeparableFilterARB glGetnSeparableFilterARB;
    da_glGetnHistogramARB glGetnHistogramARB;
    da_glGetnMinmaxARB glGetnMinmaxARB;
    da_glGetnTexImageARB glGetnTexImageARB;
    da_glReadnPixelsARB glReadnPixelsARB;
    da_glGetnCompressedTexImageARB glGetnCompressedTexImageARB;
    da_glGetnUniformfvARB glGetnUniformfvARB;
    da_glGetnUniformivARB glGetnUniformivARB;
    da_glGetnUniformuivARB glGetnUniformuivARB;
    da_glGetnUniformdvARB glGetnUniformdvARB;
}

private __gshared bool _ARB_robustness;
bool ARB_robustness() @property { return _ARB_robustness; }
package void load_ARB_robustness() {
    try {
        bindGLFunc( cast( void** )&glGetGraphicsResetStatusARB, "glGetGraphicsResetStatusARB" );
        bindGLFunc( cast( void** )&glGetnMapdvARB, "glGetnMapdvARB" );
        bindGLFunc( cast( void** )&glGetnMapfvARB, "glGetnMapfvARB" );
        bindGLFunc( cast( void** )&glGetnMapivARB, "glGetnMapivARB" );
        bindGLFunc( cast( void** )&glGetnPixelMapfvARB, "glGetnPixelMapfvARB" );
        bindGLFunc( cast( void** )&glGetnPixelMapuivARB, "glGetnPixelMapuivARB" );
        bindGLFunc( cast( void** )&glGetnPixelMapusvARB, "glGetnPixelMapusvARB" );
        bindGLFunc( cast( void** )&glGetnPolygonStippleARB, "glGetnPolygonStippleARB" );
        bindGLFunc( cast( void** )&glGetnColorTableARB, "glGetnColorTableARB" );
        bindGLFunc( cast( void** )&glGetnConvolutionFilterARB, "glGetnConvolutionFilterARB" );
        bindGLFunc( cast( void** )&glGetnSeparableFilterARB, "glGetnSeparableFilterARB" );
        bindGLFunc( cast( void** )&glGetnHistogramARB, "glGetnHistogramARB" );
        bindGLFunc( cast( void** )&glGetnMinmaxARB, "glGetnMinmaxARB" );
        bindGLFunc( cast( void** )&glGetnTexImageARB, "glGetnTexImageARB" );
        bindGLFunc( cast( void** )&glReadnPixelsARB, "glReadnPixelsARB" );
        bindGLFunc( cast( void** )&glGetnCompressedTexImageARB, "glGetnCompressedTexImageARB" );
        bindGLFunc( cast( void** )&glGetnCompressedTexImageARB, "glGetnCompressedTexImageARB" );
        bindGLFunc( cast( void** )&glGetnUniformfvARB, "glGetnUniformfvARB" );
        bindGLFunc( cast( void** )&glGetnUniformivARB, "glGetnUniformivARB" );
        bindGLFunc( cast( void** )&glGetnUniformuivARB, "glGetnUniformuivARB" );
        bindGLFunc( cast( void** )&glGetnUniformdvARB, "glGetnUniformdvARB" );
        _ARB_robustness = true;
    } catch( Exception e ) {
        _ARB_robustness = false;
    }
}

// ARB_base_instance
extern( System ) nothrow {
    alias da_glDrawArraysInstancedBaseInstance = void function( GLenum, GLint, GLsizei, GLsizei, GLuint );
    alias da_glDrawElementsInstancedBaseInstance = void function( GLenum, GLsizei, GLenum, const( void )*, GLsizei, GLuint );
    alias da_glDrawElementsInstancedBaseVertexBaseInstance = void function( GLenum, GLsizei, GLenum, const( void )*, GLsizei, GLint, GLuint );
}

__gshared {
    da_glDrawArraysInstancedBaseInstance glDrawArraysInstancedBaseInstance;
    da_glDrawElementsInstancedBaseInstance glDrawElementsInstancedBaseInstance;
    da_glDrawElementsInstancedBaseVertexBaseInstance glDrawElementsInstancedBaseVertexBaseInstance;
}

private __gshared bool _ARB_base_instance;
bool ARB_base_instance() @property { return _ARB_base_instance; }
package void load_ARB_base_instance( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glDrawArraysInstancedBaseInstance, "glDrawArraysInstancedBaseInstance" );
        bindGLFunc( cast( void** )&glDrawElementsInstancedBaseInstance, "glDrawElementsInstancedBaseInstance" );
        bindGLFunc( cast( void** )&glDrawElementsInstancedBaseVertexBaseInstance, "glDrawElementsInstancedBaseVertexBaseInstance" );
        _ARB_base_instance = true;
    } catch( Exception e ) {
        _ARB_base_instance = false;
        if( doThrow ) throw e;
    }
}

// ARB_transform_feedback_instanced
extern( System ) nothrow {
    alias da_glDrawTransformFeedbackInstanced = void function( GLenum, GLuint, GLsizei );
    alias da_glDrawTransformFeedbackStreamInstanced = void function( GLenum, GLuint, GLuint, GLsizei );
}
__gshared da_glDrawTransformFeedbackInstanced glDrawTransformFeedbackInstanced;
__gshared da_glDrawTransformFeedbackStreamInstanced glDrawTransformFeedbackStreamInstanced;

private __gshared bool _ARB_transform_feedback_instanced;
bool ARB_transform_feedback_instanced() @property { return _ARB_transform_feedback_instanced; }
package void load_ARB_transform_feedback_instanced( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glDrawTransformFeedbackInstanced, "glDrawTransformFeedbackInstanced" );
        bindGLFunc( cast( void** )&glDrawTransformFeedbackStreamInstanced, "glDrawTransformFeedbackStreamInstanced" );
        _ARB_transform_feedback_instanced = true;
    } catch( Exception e ) {
        _ARB_transform_feedback_instanced = false;
        if( doThrow ) throw e;
    }
}

// ARB_internalformat_query
extern( System ) nothrow alias da_glGetInternalformativ = void function( GLenum, GLenum, GLenum, GLsizei, GLint* );
__gshared da_glGetInternalformativ glGetInternalformativ;

private __gshared bool _ARB_internalformat_query;
bool ARB_internalformat_query() @property { return _ARB_internalformat_query; }
package void load_ARB_internalformat_query( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glGetInternalformativ, "glGetInternalformativ" );
        _ARB_internalformat_query = true;
    } catch( Exception e ) {
        _ARB_internalformat_query = false;
        if( doThrow ) throw e;
    }
}

// ARB_shader_atomic_counters
extern( System ) nothrow alias da_glGetActiveAtomicCounterBufferiv = void function( GLuint, GLuint, GLenum, GLint* );
__gshared da_glGetActiveAtomicCounterBufferiv glGetActiveAtomicCounterBufferiv;

private __gshared bool _ARB_shader_atomic_counters;
bool ARB_shader_atomic_counters() @property { return _ARB_shader_atomic_counters; }
package void load_ARB_shader_atomic_counters( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glGetActiveAtomicCounterBufferiv, "glGetActiveAtomicCounterBufferiv" );
        _ARB_shader_atomic_counters = true;
    } catch( Exception e ) {
        _ARB_shader_atomic_counters = false;
        if( doThrow ) throw e;
    }
}

// ARB_shader_image_load_store
extern( System ) nothrow {
    alias da_glBindImageTexture = void function( GLuint, GLuint, GLint, GLboolean, GLint, GLenum, GLenum );
    alias da_glMemoryBarrier = void function( GLbitfield );
}
__gshared da_glBindImageTexture glBindImageTexture;
__gshared da_glMemoryBarrier glMemoryBarrier;

private __gshared bool _ARB_shader_image_load_store;
bool ARB_shader_image_load_store() @property { return _ARB_shader_image_load_store; }
package void load_ARB_shader_image_load_store( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glBindImageTexture, "glBindImageTexture" );
        bindGLFunc( cast( void** )&glMemoryBarrier, "glMemoryBarrier" );
        _ARB_shader_image_load_store = true;
    } catch( Exception e ) {
        _ARB_shader_image_load_store = false;
        if( doThrow ) throw e;
    }
}

// ARB_texture_storage
extern( System ) nothrow {
    alias da_glTexStorage1D = void function( GLenum, GLsizei, GLenum, GLsizei );
    alias da_glTexStorage2D = void function( GLenum, GLsizei, GLenum, GLsizei, GLsizei );
    alias da_glTexStorage3D = void function( GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei );
    alias da_glTextureStorage1DEXT = void function( GLuint, GLenum, GLsizei, GLenum, GLsizei );
    alias da_glTextureStorage2DEXT = void function( GLuint, GLenum, GLsizei, GLenum, GLsizei, GLsizei );
    alias da_glTextureStorage3DEXT = void function( GLuint, GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei );
}

__gshared {
    da_glTexStorage1D glTexStorage1D;
    da_glTexStorage2D glTexStorage2D;
    da_glTexStorage3D glTexStorage3D;
    da_glTextureStorage1DEXT glTextureStorage1DEXT;
    da_glTextureStorage2DEXT glTextureStorage2DEXT;
    da_glTextureStorage3DEXT glTextureStorage3DEXT;
}

private __gshared bool _ARB_texture_storage;
bool ARB_texture_storage() @property { return _ARB_texture_storage; }
package void load_ARB_texture_storage( GLVersion glversion, bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glTexStorage1D, "glTexStorage1D" );
        bindGLFunc( cast( void** )&glTexStorage2D, "glTexStorage2D" );
        bindGLFunc( cast( void** )&glTexStorage3D, "glTexStorage3D" );

        _ARB_texture_storage = true;
    } catch( Exception e ) {
        _ARB_texture_storage = false;
        if( doThrow ) throw e;
    }
    // The next three depend on the presence of EXT_direct_state_access.
    if( isExtSupported( glversion, "GL_EXT_direct_state_access" )) {
        bindGLFunc( cast( void** )&glTextureStorage1DEXT, "glTextureStorage1DEXT" );
        bindGLFunc( cast( void** )&glTextureStorage2DEXT, "glTextureStorage2DEXT" );
        bindGLFunc( cast( void** )&glTextureStorage3DEXT, "glTextureStorage3DEXT" );
    }
}

// ARB_array_of_arrays
private __gshared bool _ARB_array_of_arrays;
bool ARB_array_of_arrays() @property { return _ARB_array_of_arrays; }

// ARB_fragment_layer_viewport
private __gshared bool _ARB_fragment_layer_viewport;
bool ARB_fragment_layer_viewport() @property { return _ARB_fragment_layer_viewport; }

// ARB_shader_image_size
private __gshared bool _ARB_shader_image_size;
bool ARB_shader_image_size() @property { return _ARB_shader_image_size; }

// ARB_ES3_compatibility
private __gshared bool _ARB_ES3_compatibility;
bool ARB_ES3_compatibility() @property { return _ARB_ES3_compatibility; }

// ARB_clear_buffer_object
extern( System ) {
    alias da_glClearBufferData = void function( GLenum,GLenum,GLenum,GLenum,const( void )* );
    alias da_glClearBufferSubData = void function( GLenum,GLenum,GLintptr,GLsizeiptr,GLenum,GLenum,const( void )* );
    alias da_glClearNamedBufferDataEXT = void function( GLuint,GLenum,GLenum,GLenum,const( void )* );
    alias da_glClearNamedBufferSubDataEXT = void function( GLuint,GLenum,GLenum,GLenum,GLsizeiptr,GLsizeiptr,const( void )* );
}

__gshared {
    da_glClearBufferData glClearBufferData;
    da_glClearBufferSubData glClearBufferSubData;
    da_glClearNamedBufferDataEXT glClearNamedBufferDataEXT;
    da_glClearNamedBufferSubDataEXT glClearNamedBufferSubDataEXT;
}
private __gshared bool _ARB_clear_buffer_object;
bool ARB_clear_buffer_object() @property { return _ARB_clear_buffer_object; }
package void load_ARB_clear_buffer_object( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glClearBufferData, "glClearBufferData" );
        bindGLFunc( cast( void** )&glClearBufferSubData, "glClearBufferSubData" );
        bindGLFunc( cast( void** )&glClearNamedBufferDataEXT, "glClearNamedBufferDataEXT" );
        bindGLFunc( cast( void** )&glClearNamedBufferSubDataEXT, "glClearNamedBufferSubDataEXT" );
        _ARB_clear_buffer_object = true;
    } catch( Exception e ) {
        _ARB_clear_buffer_object = false;
        if( doThrow ) throw e;
    }
}

// ARB_compute_shader
extern( System ) nothrow {
    alias da_glDispatchCompute = void function( GLuint,GLuint,GLuint );
    alias da_glDispatchComputeIndirect = void function( GLintptr );
}

__gshared {
    da_glDispatchCompute glDispatchCompute;
    da_glDispatchComputeIndirect glDispatchComputeIndirect;
}
private __gshared bool _ARB_compute_shader;
bool ARB_compute_shader() @property { return _ARB_compute_shader; }
package void load_ARB_compute_shader( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glDispatchCompute, "glDispatchCompute" );
        bindGLFunc( cast( void** )&glDispatchComputeIndirect, "glDispatchComputeIndirect" );
        _ARB_compute_shader = true;
    } catch( Exception e ) {
        _ARB_compute_shader = false;
        if( doThrow ) throw e;
    }
}

// ARB_copy_image
private __gshared bool _ARB_copy_image;
bool ARB_copy_image() @property { return _ARB_copy_image; }

// KHR_debug
extern( System ) nothrow {
    // GLDEBUGPROC is a callback type -- don't try to load it!
    alias GLDEBUGPROC = void function( GLenum,GLenum,GLuint,GLenum,GLsizei,const( GLchar )*,GLvoid* );

    // These are the functions that need loading.
    alias da_glDebugMessageControl = void function( GLenum,GLenum,GLenum,GLsizei,const( GLuint* ),GLboolean );
    alias da_glDebugMessageInsert = void function( GLenum,GLenum,GLuint,GLenum,GLsizei,const( GLchar )* );
    alias da_glDebugMessageCallback = void function( GLDEBUGPROC,const( void )* );
    alias da_glGetDebugMessageLog = GLuint function( GLuint,GLsizei,GLenum*,GLenum*,GLuint*,GLenum*,GLsizei*,GLchar* );
    alias da_glPushDebugGroup = void function( GLenum,GLuint,GLsizei,const( GLchar )* );
    alias da_glPopDebugGroup = void function();
    alias da_glObjectLabel = void function( GLenum,GLuint,GLsizei,GLsizei,const( GLchar )* );
    alias da_glGetObjectLabel = void function( GLenum,GLuint,GLsizei,GLsizei*,GLchar* );
    alias da_glObjectPtrLabel = void function( const( void )*,GLsizei,const( GLchar )* );
    alias da_glGetObjectPtrLabel = void function( const( void )*,GLsizei,GLsizei*,GLchar* );

}
__gshared {
    da_glDebugMessageControl glDebugMessageControl;
    da_glDebugMessageInsert glDebugMessageInsert;
    da_glDebugMessageCallback glDebugMessageCallback;
    da_glGetDebugMessageLog glGetDebugMessageLog;
    da_glPushDebugGroup glPushDebugGroup;
    da_glPopDebugGroup glPopDebugGroup;
    da_glObjectLabel glObjectLabel;
    da_glGetObjectLabel glGetObjectLabel;
    da_glObjectPtrLabel glObjectPtrLabel;
    da_glGetObjectPtrLabel glGetObjectPtrLabel;
}
private __gshared bool _KHR_debug;
bool KHR_debug() @property { return _KHR_debug; }
package void load_KHR_debug( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glDebugMessageControl, "glDebugMessageControl" );
        bindGLFunc( cast( void** )&glDebugMessageInsert, "glDebugMessageInsert" );
        bindGLFunc( cast( void** )&glDebugMessageCallback, "glDebugMessageCallback" );
        bindGLFunc( cast( void** )&glGetDebugMessageLog, "glGetDebugMessageLog" );
        bindGLFunc( cast( void** )&glPushDebugGroup, "glPushDebugGroup" );
        bindGLFunc( cast( void** )&glPopDebugGroup, "glPopDebugGroup" );
        bindGLFunc( cast( void** )&glObjectLabel, "glObjectLabel" );
        bindGLFunc( cast( void** )&glGetObjectLabel, "glGetObjectLabel" );
        bindGLFunc( cast( void** )&glObjectPtrLabel, "glObjectPtrLabel" );
        bindGLFunc( cast( void** )&glGetObjectPtrLabel, "glGetObjectPtrLabel" );
        _KHR_debug = true;
    } catch( Exception e ) {
        _KHR_debug = false;
        if( doThrow ) throw e;
    }
}

// ARB_explicit_uniform_location
private __gshared bool _ARB_explicit_uniform_location;
bool ARB_explicit_uniform_location() @property { return _ARB_explicit_uniform_location; }

// ARB_framebuffer_no_attachments
extern( System ) nothrow {
    alias da_glFramebufferParameteri = void function( GLenum,GLenum,GLint );
    alias da_glGetFramebufferParameteriv = void function( GLenum,GLenum,GLint* );
    alias da_glNamedFramebufferParameteriEXT = void function( GLuint,GLenum,GLint );
    alias da_glGetNamedFramebufferParameterivEXT = void function( GLuint,GLenum,GLint* );
}

__gshared {
    da_glFramebufferParameteri glFramebufferParameteri;
    da_glGetFramebufferParameteriv glGetFramebufferParameteriv;
    da_glNamedFramebufferParameteriEXT glNamedFramebufferParameteriEXT;
    da_glGetNamedFramebufferParameterivEXT glGetNamedFramebufferParameterivEXT;
}
private __gshared bool _ARB_framebuffer_no_attachments;
bool ARB_framebuffer_no_attachments() @property { return _ARB_framebuffer_no_attachments; }
package void load_ARB_framebuffer_no_attachments( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glFramebufferParameteri, "glFramebufferParameteri" );
        bindGLFunc( cast( void** )&glGetFramebufferParameteriv, "glGetFramebufferParameteriv" );
        bindGLFunc( cast( void** )&glNamedFramebufferParameteriEXT, "glNamedFramebufferParameteriEXT" );
        bindGLFunc( cast( void** )&glGetNamedFramebufferParameterivEXT, "glGetNamedFramebufferParameterivEXT" );
        _ARB_framebuffer_no_attachments = true;
    } catch( Exception e ) {
        _ARB_framebuffer_no_attachments = false;
        if( doThrow ) throw e;
    }
}

// ARB_internalformat_query2
extern( System ) nothrow alias da_glGetInternalformati64v = void function( GLenum,GLenum,GLenum,GLsizei,GLint64* );
__gshared da_glGetInternalformati64v glGetInternalformati64v;
private __gshared bool _ARB_internalformat_query2;
bool ARB_internalformat_query2() @property { return _ARB_internalformat_query2; }
package void load_ARB_internalformat_query2( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glGetInternalformati64v, "glGetInternalformati64v" );
        _ARB_internalformat_query2 = true;
    } catch( Exception e ) {
        _ARB_internalformat_query2 = false;
        if( doThrow ) throw e;
    }
}

// ARB_invalidate_subdata
extern( System ) nothrow {
    alias da_glInvalidateTexSubImage = void function( GLuint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei );
    alias da_glInvalidateTexImage = void function( GLuint,GLint );
    alias da_glInvalidateBufferSubData = void function( GLuint,GLintptr,GLsizeiptr );
    alias da_glInvalidateBufferData = void function( GLuint );
    alias da_glInvalidateFramebuffer = void function( GLenum,GLsizei,const( GLenum )* );
    alias da_glInvalidateSubFramebuffer = void function( GLenum,GLsizei,const( GLenum )*,GLint,GLint,GLsizei,GLsizei );
}

__gshared {
    da_glInvalidateTexSubImage glInvalidateTexSubImage;
    da_glInvalidateTexImage glInvalidateTexImage;
    da_glInvalidateBufferSubData glInvalidateBufferSubData;
    da_glInvalidateBufferData glInvalidateBufferData;
    da_glInvalidateFramebuffer glInvalidateFramebuffer;
    da_glInvalidateSubFramebuffer glInvalidateSubFramebuffer;
}
private __gshared bool _ARB_invalidate_subdata;
bool ARB_invalidate_subdata() @property { return _ARB_invalidate_subdata; }
package void load_ARB_invalidate_subdata( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glInvalidateTexSubImage, "glInvalidateTexSubImage" );
        bindGLFunc( cast( void** )&glInvalidateTexImage, "glInvalidateTexImage" );
        bindGLFunc( cast( void** )&glInvalidateBufferSubData, "glInvalidateBufferSubData" );
        bindGLFunc( cast( void** )&glInvalidateBufferData, "glInvalidateBufferData" );
        bindGLFunc( cast( void** )&glInvalidateFramebuffer, "glInvalidateFramebuffer" );
        bindGLFunc( cast( void** )&glInvalidateSubFramebuffer, "glInvalidateSubFramebuffer" );
        _ARB_invalidate_subdata = true;
    }
    catch( Exception e ) {
        _ARB_invalidate_subdata = false;
        if( doThrow ) throw e;
    }
}

// ARB_multi_draw_indirect
extern( System ) nothrow {
    alias da_glMultiDrawArraysIndirect = void function( GLenum,const( void )*,GLsizei,GLsizei );
    alias da_glMultiDrawElementsIndirect = void function( GLenum,GLenum,const( void )*,GLsizei,GLsizei );
}
__gshared da_glMultiDrawArraysIndirect glMultiDrawArraysIndirect;
__gshared da_glMultiDrawElementsIndirect glMultiDrawElementsIndirect;
private __gshared bool _ARB_multi_draw_indirect;
bool ARB_multi_draw_indirect() @property { return _ARB_multi_draw_indirect; }
package void load_ARB_multi_draw_indirect( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glMultiDrawArraysIndirect, "glMultiDrawArraysIndirect" );
        bindGLFunc( cast( void** )&glMultiDrawElementsIndirect, "glMultiDrawElementsIndirect" );
        _ARB_multi_draw_indirect = true;
    } catch( Exception e ) {
        _ARB_multi_draw_indirect = false;
        if( doThrow ) throw e;
    }
}

// ARB_program_interface_query
extern( System ) nothrow {
    alias da_glGetProgramInterfaceiv = void function( GLuint,GLenum,GLenum,GLint* );
    alias da_glGetProgramResourceIndex = GLuint function( GLuint,GLenum,const( GLchar )* );
    alias da_glGetProgramResourceName = void function( GLuint,GLenum,GLuint,GLsizei,GLsizei*,GLchar* );
    alias da_glGetProgramResourceiv = void function( GLuint,GLenum,GLuint,GLsizei,const( GLenum )*,GLsizei,GLsizei*,GLint* );
    alias da_glGetProgramResourceLocation = GLint function( GLuint,GLenum,const( GLchar )* );
    alias da_glGetProgramResourceLocationIndex = GLint function( GLuint,GLenum,const( GLchar )* );
}

__gshared {
    da_glGetProgramInterfaceiv glGetProgramInterfaceiv;
    da_glGetProgramResourceIndex glGetProgramResourceIndex;
    da_glGetProgramResourceName glGetProgramResourceName;
    da_glGetProgramResourceiv glGetProgramResourceiv;
    da_glGetProgramResourceLocation glGetProgramResourceLocation;
    da_glGetProgramResourceLocationIndex glGetProgramResourceLocationIndex;
}

private __gshared bool _ARB_program_interface_query;
bool ARB_program_interface_query() @property { return _ARB_program_interface_query; }
package void load_ARB_program_interface_query( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glGetProgramInterfaceiv, "glGetProgramInterfaceiv" );
        bindGLFunc( cast( void** )&glGetProgramResourceIndex, "glGetProgramResourceIndex" );
        bindGLFunc( cast( void** )&glGetProgramResourceName, "glGetProgramResourceName" );
        bindGLFunc( cast( void** )&glGetProgramResourceiv, "glGetProgramResourceiv" );
        bindGLFunc( cast( void** )&glGetProgramResourceLocation, "glGetProgramResourceLocation" );
        bindGLFunc( cast( void** )&glGetProgramResourceLocationIndex, "glGetProgramResourceLocationIndex" );
        _ARB_program_interface_query = true;
    } catch( Exception e ) {
        _ARB_program_interface_query = false;
        if( doThrow ) throw e;
    }
}

// ARB_robust_buffer_access_behavior
private __gshared bool _ARB_robust_buffer_access_behavior;
bool ARB_robust_buffer_access_behavior() @property { return _ARB_robust_buffer_access_behavior; }

// ARB_shader_storage_buffer_object
extern( System ) alias da_glShaderStorageBlockBinding = void function( GLuint,GLuint,GLuint );
__gshared da_glShaderStorageBlockBinding glShaderStorageBlockBinding;
private __gshared bool _ARB_shader_storage_buffer_object;
bool ARB_shader_storage_buffer_object() @property { return _ARB_shader_storage_buffer_object; }
package void load_ARB_shader_storage_buffer_object( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glShaderStorageBlockBinding, "glShaderStorageBlockBinding" );
        _ARB_shader_storage_buffer_object = true;
    } catch( Exception e ) {
        _ARB_shader_storage_buffer_object = false;
        if( doThrow ) throw e;
    }
}

// ARB_stencil_texturing
private __gshared bool _ARB_stencil_texturing;
bool ARB_stencil_texturing() @property { return _ARB_stencil_texturing; }

// ARB_texture_buffer_range
extern( System ) nothrow {
    alias da_glTexBufferRange = void function( GLenum,GLenum,GLuint,GLintptr,GLsizeiptr );
    alias da_glTextureBufferRangeEXT = void function( GLuint,GLenum,GLenum,GLuint,GLintptr,GLsizeiptr );
}
__gshared da_glTexBufferRange glTexBufferRange;
__gshared da_glTextureBufferRangeEXT glTextureBufferRangeEXT;
private __gshared bool _ARB_texture_buffer_range;
bool ARB_texture_buffer_range() @property { return _ARB_texture_buffer_range; }
package void load_ARB_texture_buffer_range( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glTexBufferRange, "glTexBufferRange" );
        bindGLFunc( cast( void** )&glTextureBufferRangeEXT, "glTextureBufferRangeEXT" );
        _ARB_texture_buffer_range = true;
    } catch( Exception e ) {
        _ARB_texture_buffer_range = false;
        if( doThrow ) throw e;
    }
}

// ARB_texture_query_levels
private __gshared bool _ARB_texture_query_levels;
bool ARB_texture_query_levels() @property { return _ARB_texture_query_levels; }

// ARB_texture_storage_multisample
extern( System ) nothrow {
    alias da_glTexStorage2DMultisample = void function( GLenum,GLsizei,GLenum,GLsizei,GLsizei,GLboolean );
    alias da_glTexStorage3DMultisample = void function( GLenum,GLsizei,GLenum,GLsizei,GLsizei,GLsizei,GLboolean );
    alias da_glTextureStorage2DMultisampleEXT = void function( GLuint,GLenum,GLsizei,GLenum,GLsizei,GLsizei,GLboolean );
    alias da_glTextureStorage3DMultisampleEXT = void function( GLuint,GLenum,GLsizei,GLenum,GLsizei,GLsizei,GLsizei,GLboolean );
}

__gshared {
    da_glTexStorage2DMultisample glTexStorage2DMultisample;
    da_glTexStorage3DMultisample glTexStorage3DMultisample;
    da_glTextureStorage2DMultisampleEXT glTextureStorage2DMultisampleEXT;
    da_glTextureStorage3DMultisampleEXT glTextureStorage3DMultisampleEXT;
}

private __gshared bool _ARB_texture_storage_multisample;
bool ARB_texture_storage_multisample() @property { return _ARB_texture_storage_multisample; }
package void load_ARB_texture_storage_multisample( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glTexStorage2DMultisample, "glTexStorage2DMultisample" );
        bindGLFunc( cast( void** )&glTexStorage3DMultisample, "glTexStorage3DMultisample" );
        bindGLFunc( cast( void** )&glTextureStorage2DMultisampleEXT, "glTextureStorage2DMultisampleEXT" );
        bindGLFunc( cast( void** )&glTextureStorage3DMultisampleEXT, "glTextureStorage3DMultisampleEXT" );
        _ARB_texture_storage_multisample = true;
    } catch( Exception e ) {
        _ARB_texture_storage_multisample = false;
        if( doThrow ) throw e;
    }
}

// ARB_texture_view
extern( System ) nothrow alias da_glTextureView = void function( GLuint,GLenum,GLuint,GLenum,GLuint,GLuint,GLuint,GLuint );
__gshared da_glTextureView glTextureView;
private __gshared bool _ARB_texture_view;
bool ARB_texture_view() @property { return _ARB_texture_view; }
package void load_ARB_texture_view( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glTextureView, "glTextureView" );
        _ARB_texture_view = true;
    } catch( Exception e ) {
        _ARB_texture_view = false;
        if( doThrow ) throw e;
    }
}

// ARB_vertex_attrib_binding
extern( System ) nothrow {
    alias da_glBindVertexBuffer = void function( GLuint,GLuint,GLintptr,GLsizei );
    alias da_glVertexAttribFormat = void function( GLuint,GLint,GLenum,GLboolean,GLuint );
    alias da_glVertexAttribIFormat = void function( GLuint,GLint,GLenum,GLuint );
    alias da_glVertexAttribLFormat = void function( GLuint,GLint,GLenum,GLuint );
    alias da_glVertexAttribBinding = void function( GLuint,GLuint );
    alias da_glVertexBindingDivisor = void function( GLuint,GLuint );
    alias da_glVertexArrayBindVertexBufferEXT = void function( GLuint,GLuint,GLuint,GLintptr,GLsizei );
    alias da_glVertexArrayVertexAttribFormatEXT = void function( GLuint,GLuint,GLint,GLenum,GLboolean,GLuint );
    alias da_glVertexArrayVertexAttribIFormatEXT = void function( GLuint,GLuint,GLint,GLenum,GLuint );
    alias da_glVertexArrayVertexAttribLFormatEXT = void function( GLuint,GLuint,GLint,GLenum,GLuint );
    alias da_glVertexArrayVertexAttribBindingEXT = void function( GLuint,GLuint,GLuint );
    alias da_glVertexArrayVertexBindingDivisorEXT = void function( GLuint,GLuint,GLuint );
}

__gshared {
    da_glBindVertexBuffer glBindVertexBuffer;
    da_glVertexAttribFormat glVertexAttribFormat;
    da_glVertexAttribIFormat glVertexAttribIFormat;
    da_glVertexAttribLFormat glVertexAttribLFormat;
    da_glVertexAttribBinding glVertexAttribBinding;
    da_glVertexBindingDivisor glVertexBindingDivisor;
    da_glVertexArrayBindVertexBufferEXT glVertexArrayBindVertexBufferEXT;
    da_glVertexArrayVertexAttribFormatEXT glVertexArrayVertexAttribFormatEXT;
    da_glVertexArrayVertexAttribIFormatEXT glVertexArrayVertexAttribIFormatEXT;
    da_glVertexArrayVertexAttribLFormatEXT glVertexArrayVertexAttribLFormatEXT;
    da_glVertexArrayVertexAttribBindingEXT glVertexArrayVertexAttribBindingEXT;
    da_glVertexArrayVertexBindingDivisorEXT glVertexArrayVertexBindingDivisorEXT;
}

private __gshared bool _ARB_vertex_attrib_binding;
bool ARB_vertex_attrib_binding() @property { return _ARB_vertex_attrib_binding; }
package void load_ARB_vertex_attrib_binding( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glBindVertexBuffer, "glBindVertexBuffer" );
        bindGLFunc( cast( void** )&glVertexAttribFormat, "glVertexAttribFormat" );
        bindGLFunc( cast( void** )&glVertexAttribIFormat, "glVertexAttribIFormat" );
        bindGLFunc( cast( void** )&glVertexAttribLFormat, "glVertexAttribLFormat" );
        bindGLFunc( cast( void** )&glVertexAttribBinding, "glVertexAttribBinding" );
        bindGLFunc( cast( void** )&glVertexBindingDivisor, "glVertexBindingDivisor" );
        bindGLFunc( cast( void** )&glVertexArrayBindVertexBufferEXT, "glVertexArrayBindVertexBufferEXT" );
        bindGLFunc( cast( void** )&glVertexArrayVertexAttribFormatEXT, "glVertexArrayVertexAttribFormatEXT" );
        bindGLFunc( cast( void** )&glVertexArrayVertexAttribIFormatEXT, "glVertexArrayVertexAttribIFormatEXT" );
        bindGLFunc( cast( void** )&glVertexArrayVertexAttribLFormatEXT, "glVertexArrayVertexAttribLFormatEXT" );
        bindGLFunc( cast( void** )&glVertexArrayVertexAttribBindingEXT, "glVertexArrayVertexAttribBindingEXT" );
        bindGLFunc( cast( void** )&glVertexArrayVertexBindingDivisorEXT, "glVertexArrayVertexBindingDivisorEXT" );
        _ARB_vertex_attrib_binding = true;
    } catch( Exception e ) {
        _ARB_vertex_attrib_binding = false;
        if( doThrow ) throw e;
    }
}

package void loadARB( GLVersion glversion )
{
    if( glversion  < GLVersion.GL30 ) {
        if( isExtSupported( glversion, "GL_ARB_framebuffer_object" ) ) load_ARB_framebuffer_object();
        if( isExtSupported( glversion, "GL_ARB_map_buffer_range" ) ) load_ARB_map_buffer_range();
        if( isExtSupported( glversion, "GL_ARB_vertex_array_object" ) ) load_ARB_vertex_array_object();
    }

    if( glversion < GLVersion.GL31 ) {
        if( isExtSupported( glversion, "GL_ARB_copy_buffer" ) ) load_ARB_copy_buffer();
        if( isExtSupported( glversion, "GL_ARB_uniform_buffer_object" ) ) load_ARB_uniform_buffer_object();
    }

    if( glversion < GLVersion.GL32 ) {
        if( isExtSupported( glversion, "GL_ARB_draw_elements_base_vertex" ) ) load_ARB_draw_elements_base_vertex();
        if( isExtSupported( glversion, "GL_ARB_provoking_vertex" ) ) load_ARB_provoking_vertex();
        if( isExtSupported( glversion, "GL_ARB_sync" ) ) load_ARB_sync();
        if( isExtSupported( glversion, "GL_ARB_texture_multisample" ) ) load_ARB_texture_multisample();
    }

    if( glversion < GLVersion.GL33 ) {
        if( isExtSupported( glversion, "GL_ARB_blend_func_extended" ) ) load_ARB_blend_func_extended();
        if( isExtSupported( glversion, "GL_ARB_sampler_objects" ) ) load_ARB_sampler_objects();
        _ARB_explicit_attrib_location = isExtSupported( glversion, "GL_ARB_explicit_attrib_location" );
        _ARB_occlusion_query2 = isExtSupported( glversion, "GL_ARB_occlusion_query2" );
        _ARB_shader_bit_encoding = isExtSupported( glversion, "GL_ARB_shader_bit_encoding" );
        _ARB_texture_rgb10_a2ui = isExtSupported( glversion, "GL_ARB_texture_rgb10_a2ui" );
        _ARB_texture_swizzle = isExtSupported( glversion, "GL_ARB_texture_swizzle" );
        if( isExtSupported( glversion, "GL_ARB_timer_query" ) ) load_ARB_timer_query();
        if( isExtSupported( glversion, "GL_ARB_vertex_type_2_10_10_10_rev" ) ) load_ARB_vertex_type_2_10_10_10_rev();
    }

    if( glversion < GLVersion.GL40 ) {
        _ARB_texture_query_lod = isExtSupported( glversion, "GL_ARB_texture_query_lod" );
        if( isExtSupported( glversion, "GL_ARB_draw_indirect" ) ) load_ARB_draw_indirect();
        _ARB_gpu_shader5 = isExtSupported( glversion, "GL_ARB_gpu_shader5" );
        if( isExtSupported( glversion, "GL_ARB_gpu_shader_fp64" ) ) load_ARB_gpu_shader_fp64();
        if( isExtSupported( glversion, "GL_ARB_shader_subroutine" ) ) load_ARB_shader_subroutine();
        if( isExtSupported( glversion, "GL_ARB_tessellation_shader" ) ) load_ARB_tessellation_shader();
        _ARB_texture_buffer_object_rgb32 = isExtSupported( glversion, "GL_ARB_texture_buffer_object_rgb32" );
        _ARB_texture_cube_map_array = isExtSupported( glversion, "GL_ARB_texture_cube_map_array" );
        _ARB_texture_gather = isExtSupported( glversion, "GL_ARB_texture_gather" );
        if( isExtSupported( glversion, "GL_ARB_transform_feedback2" ) ) load_ARB_transform_feedback2();
        if( isExtSupported( glversion, "GL_ARB_transform_feedback3" ) ) load_ARB_transform_feedback3();
    }

    if( glversion < GLVersion.GL41 ) {
        if( isExtSupported( glversion, "GL_ARB_ES2_compatibility" ) ) load_ARB_ES2_compatibility();
        if( isExtSupported( glversion, "GL_ARB_get_program_binary" ) ) load_ARB_get_program_binary();
        if( isExtSupported( glversion, "GL_ARB_separate_shader_objects" ) ) load_ARB_separate_shader_objects();
        _ARB_shader_precision = isExtSupported( glversion, "GL_ARB_shader_precision" );
        if( isExtSupported( glversion, "GL_ARB_vertex_attrib_64bit" ) ) load_ARB_vertex_attrib_64bit();
        if( isExtSupported( glversion, "GL_ARB_viewport_array" ) ) load_ARB_viewport_array();
    }

    if( glversion < GLVersion.GL42 ) {
        if( isExtSupported( glversion, "GL_ARB_base_instance" ) ) load_ARB_base_instance();
        _ARB_shading_language_420pack = isExtSupported( glversion, "GL_ARB_shading_language_420pack" );
        if( isExtSupported( glversion, "GL_ARB_transform_feedback_instanced" ) ) load_ARB_transform_feedback_instanced();
        _ARB_compressed_texture_pixel_storage = isExtSupported( glversion, "GL_ARB_compressed_texture_pixel_storage" );
        _ARB_conservative_depth = isExtSupported( glversion, "GL_ARB_conservative_depth" );
        if( isExtSupported( glversion, "GL_ARB_internalformat_query" ) ) load_ARB_internalformat_query();
        _ARB_map_buffer_alignment = isExtSupported( glversion, "GL_ARB_map_buffer_alignment" );
        if( isExtSupported( glversion, "GL_ARB_shader_atomic_counters" ) ) load_ARB_shader_atomic_counters();
        if( isExtSupported( glversion, "GL_ARB_shader_image_load_store" ) ) load_ARB_shader_image_load_store();
        _ARB_shading_language_packing = isExtSupported( glversion, "GL_ARB_shading_language_packing" );
        if( isExtSupported( glversion, "GL_ARB_texture_storage" ) ) load_ARB_texture_storage( glversion );
    }

    if( glversion< GLVersion.GL43 ) {
        _ARB_array_of_arrays = isExtSupported( glversion, "GL_ARB_array_of_arrays" );
        _ARB_fragment_layer_viewport = isExtSupported( glversion, "GL_ARB_fragment_layer_viewport" );
        _ARB_shader_image_size = isExtSupported( glversion, "GL_ARB_shader_image_size" );
        _ARB_ES3_compatibility = isExtSupported( glversion, "GL_ARB_ES3_compatibility" );
        if( isExtSupported( glversion, "GL_ARB_clear_ buffer_object" )  ) load_ARB_clear_buffer_object();
        if( isExtSupported( glversion, "GL_ARB_compute_shader" ) ) load_ARB_compute_shader();
        _ARB_copy_image = isExtSupported( glversion, "GL_ARB_copy_image" );
        if( isExtSupported( glversion, "GL_KHR_debug" ) ) load_KHR_debug();
        _ARB_explicit_uniform_location = isExtSupported( glversion, "GL_ARB_explicit_uniform_location" );
        if( isExtSupported( glversion, "GL_ARB_framebuffer_no_attachments" ) ) load_ARB_framebuffer_no_attachments();
        if( isExtSupported( glversion, "GL_ARB_internalformat_query2" ) ) load_ARB_internalformat_query2();
        if( isExtSupported( glversion,"GL_ARB_invalidate_subdata" ) ) load_ARB_invalidate_subdata();
        if( isExtSupported( glversion,"GL_ARB_multi_draw_indirect" ) ) load_ARB_multi_draw_indirect();
        if( isExtSupported( glversion, "GL_ARB_program_interface_query" ) ) load_ARB_program_interface_query();
        _ARB_robust_buffer_access_behavior = isExtSupported( glversion, "GL_ARB_robust_buffer_access_behavior" );
        if( isExtSupported( glversion, "GL_ARB_shader_storage_buffer_object" ) ) load_ARB_shader_storage_buffer_object();
        _ARB_stencil_texturing = isExtSupported( glversion, "GL_ARB_stencil_texturing" );
        if( isExtSupported( glversion, "GL_ARB_texture_buffer_range" ) ) load_ARB_texture_buffer_range();
        _ARB_texture_query_levels = isExtSupported( glversion, "GL_ARB_texture_query_levels" );
        if( isExtSupported( glversion, "GL_ARB_texture_storage_multisample" ) ) load_ARB_texture_storage_multisample();
        if( isExtSupported( glversion,"GL_ARB_texture_view" ) ) load_ARB_texture_view();
        if( isExtSupported( glversion, "GL_ARB_vertex_attrib_binding" ) ) load_ARB_vertex_attrib_binding();
    }
}
