/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/
module derelict.opengl3.internal.glxplatform;

private import derelict.util.system;

static if( Derelict_OS_Posix && !Derelict_OS_Mac ) {
    private import derelict.opengl3.internal.types;

    void* loadGLFunc( alias ctx )( string symName ) {
        import std.string : toStringz;
        return ctx.glXGetProcAddress( symName.toStringz() );
    }

    bool hasValidContext( alias ctx )() {
        if( ctx.glXGetCurrentContext && ctx.glXGetCurrentContext() )
            return true;
        return false;
    }

    void loadPlatformGL( alias ctx )( void delegate( void**, string, bool doThrow ) bindFunc ) {
        bindFunc( cast( void** )&ctx.glXChooseVisual, "glXChooseVisual", true );
        bindFunc( cast( void** )&ctx.glXCopyContext, "glXCopyContext", true );
        bindFunc( cast( void** )&ctx.glXCreateContext, "glXCreateContext", true );
        bindFunc( cast( void** )&ctx.glXCreateGLXPixmap, "glXCreateGLXPixmap", true );
        bindFunc( cast( void** )&ctx.glXDestroyContext, "glXDestroyContext", true );
        bindFunc( cast( void** )&ctx.glXDestroyGLXPixmap, "glXDestroyGLXPixmap", true );
        bindFunc( cast( void** )&ctx.glXGetConfig, "glXGetConfig", true );
        bindFunc( cast( void** )&ctx.glXGetCurrentContext, "glXGetCurrentContext", true );
        bindFunc( cast( void** )&ctx.glXGetCurrentDrawable, "glXGetCurrentDrawable", true );
        bindFunc( cast( void** )&ctx.glXIsDirect, "glXIsDirect", true );
        bindFunc( cast( void** )&ctx.glXMakeCurrent, "glXMakeCurrent", true );
        bindFunc( cast( void** )&ctx.glXQueryExtension, "glXQueryExtension", true );
        bindFunc( cast( void** )&ctx.glXQueryVersion, "glXQueryVersion", true );
        bindFunc( cast( void** )&ctx.glXSwapBuffers, "glXSwapBuffers", true );
        bindFunc( cast( void** )&ctx.glXUseXFont, "glXUseXFont", true );
        bindFunc( cast( void** )&ctx.glXWaitGL, "glXWaitGL", true );
        bindFunc( cast( void** )&ctx.glXWaitX, "glXWaitX", true );
        bindFunc( cast( void** )&ctx.glXGetClientString, "glXGetClientString", true );
        bindFunc( cast( void** )&ctx.glXQueryServerString, "glXQueryServerString", true );
        bindFunc( cast( void** )&ctx.glXQueryExtensionsString, "glXQueryExtensionsString", true );

        bindFunc( cast( void** )&ctx.glXGetFBConfigs, "glXGetFBConfigs", true );
        bindFunc( cast( void** )&ctx.glXChooseFBConfig, "glXChooseFBConfig", true );
        bindFunc( cast( void** )&ctx.glXGetFBConfigAttrib, "glXGetFBConfigAttrib", true );
        bindFunc( cast( void** )&ctx.glXGetVisualFromFBConfig, "glXGetVisualFromFBConfig", true );
        bindFunc( cast( void** )&ctx.glXCreateWindow, "glXCreateWindow", true );
        bindFunc( cast( void** )&ctx.glXDestroyWindow, "glXDestroyWindow", true );
        bindFunc( cast( void** )&ctx.glXCreatePixmap, "glXCreatePixmap", true );
        bindFunc( cast( void** )&ctx.glXDestroyPixmap, "glXDestroyPixmap", true );
        bindFunc( cast( void** )&ctx.glXCreatePbuffer, "glXCreatePbuffer", true );
        bindFunc( cast( void** )&ctx.glXDestroyPbuffer, "glXDestroyPbuffer", true );
        bindFunc( cast( void** )&ctx.glXQueryDrawable, "glXQueryDrawable", true );
        bindFunc( cast( void** )&ctx.glXCreateNewContext, "glXCreateNewContext", true );
        bindFunc( cast( void** )&ctx.glXMakeContextCurrent, "glXMakeContextCurrent", true );
        bindFunc( cast( void** )&ctx.glXGetCurrentReadDrawable, "glXGetCurrentReadDrawable", true );
        bindFunc( cast( void** )&ctx.glXGetCurrentDisplay, "glXGetCurrentDisplay", true );
        bindFunc( cast( void** )&ctx.glXQueryContext, "glXQueryContext", true );
        bindFunc( cast( void** )&ctx.glXSelectEvent, "glXSelectEvent", true );
        bindFunc( cast( void** )&ctx.glXGetSelectedEvent, "glXGetSelectedEvent", true );

        bindFunc( cast( void** )&ctx.glXGetProcAddress, "glXGetProcAddressARB", true );
    }

    void loadPlatformEXT( alias ctx )( GLVersion glversion ) {
        import derelict.opengl3.internal.common;

        if ( isExtSupported!ctx( glversion, "GLX_ARB_create_context" )) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXCreateContextAttribsARB, "glXCreateContextAttribsARB" );
                ctx.GLX_ARB_create_context = true;
            } catch ( Exception e ) {
                ctx.GLX_ARB_create_context = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_ARB_get_proc_address" ))
        {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXGetProcAddressARB, "glXGetProcAddressARB" );
                ctx.GLX_ARB_get_proc_address = true;
            } catch ( Exception e ) {
                ctx.GLX_ARB_get_proc_address = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_EXT_import_context" )) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXGetCurrentDisplayEXT, "glXGetCurrentDisplayEXT" );
                bindGLFunc!ctx( cast( void** )&ctx.glXQueryContextInfoEXT, "glXQueryContextInfoEXT" );
                bindGLFunc!ctx( cast( void** )&ctx.glXGetContextIDEXT, "glXGetContextIDEXT" );
                bindGLFunc!ctx( cast( void** )&ctx.glXImportContextEXT, "glXImportContextEXT" );
                bindGLFunc!ctx( cast( void** )&ctx.glXFreeContextEXT, "glXFreeContextEXT" );
                ctx.GLX_EXT_import_context = true;
            } catch ( Exception e ) {
                ctx.GLX_EXT_import_context = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_EXT_swap_control" )) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXSwapIntervalEXT, "glXSwapIntervalEXT" );
                ctx.GLX_EXT_swap_control = true;
            } catch ( Exception e ) {
                ctx.GLX_EXT_swap_control = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_EXT_texture_from_pixmap" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXBindTexImageEXT, "glXBindTexImageEXT" );
                bindGLFunc!ctx( cast( void** )&ctx.glXReleaseTexImageEXT, "glXReleaseTexImageEXT" );
                ctx.GLX_EXT_texture_from_pixmap = true;
            } catch ( Exception e ) {
                ctx.GLX_EXT_texture_from_pixmap = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_MESA_agp_offset" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXGetAGPOffsetMESA, "glXGetAGPOffsetMESA" );
                ctx.GLX_MESA_agp_offset = true;
            } catch ( Exception e ) {
                ctx.GLX_MESA_agp_offset = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_MESA_pixmap_colormap" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXCreateGLXPixmapMESA, "glXCreateGLXPixmapMESA" );
                ctx.GLX_MESA_pixmap_colormap = true;
            } catch ( Exception e ) {
                ctx.GLX_MESA_pixmap_colormap = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_MESA_release_buffers" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXReleaseBuffersMESA, "glXReleaseBuffersMESA" );
                ctx.GLX_MESA_release_buffers = true;
            } catch ( Exception e ) {
                ctx.GLX_MESA_release_buffers = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_MESA_set_3dfx_mode" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXSet3DfxModeMESA, "glXSet3DfxModeMESA" );
                ctx.GLX_MESA_set_3dfx_mode = true;
            } catch ( Exception e ) {
                ctx.GLX_MESA_set_3dfx_mode = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_NV_copy_image" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXCopyImageSubDataNV, "glXCopyImageSubDataNV" );
                ctx.GLX_NV_copy_image = true;
            } catch ( Exception e ) {
                ctx.GLX_NV_copy_image = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_NV_present_video" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXEnumerateVideoDevicesNV, "glXEnumerateVideoDevicesNV" );
                bindGLFunc!ctx( cast( void** )&ctx.glXBindVideoDeviceNV, "glXBindVideoDeviceNV" );
                ctx.GLX_NV_present_video = true;
            } catch ( Exception e ) {
                ctx.GLX_NV_present_video = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_NV_swap_group" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXJoinSwapGroupNV, "glXJoinSwapGroupNV" );
                bindGLFunc!ctx( cast( void** )&ctx.glXBindSwapBarrierNV, "glXBindSwapBarrierNV" );
                bindGLFunc!ctx( cast( void** )&ctx.glXQuerySwapGroupNV, "glXQuerySwapGroupNV" );
                bindGLFunc!ctx( cast( void** )&ctx.glXQueryMaxSwapGroupsNV, "glXQueryMaxSwapGroupsNV" );
                bindGLFunc!ctx( cast( void** )&ctx.glXQueryFrameCountNV, "glXQueryFrameCountNV" );
                bindGLFunc!ctx( cast( void** )&ctx.glXResetFrameCountNV, "glXResetFrameCountNV" );
                ctx.GLX_NV_swap_group = true;
            } catch ( Exception e ) {
                ctx.GLX_NV_swap_group = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_NV_video_capture" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXBindVideoCaptureDeviceNV, "glXBindVideoCaptureDeviceNV" );
                bindGLFunc!ctx( cast( void** )&ctx.glXEnumerateVideoCaptureDevicesNV, "glXEnumerateVideoCaptureDevicesNV" );
                bindGLFunc!ctx( cast( void** )&ctx.glXLockVideoCaptureDeviceNV, "glXLockVideoCaptureDeviceNV" );
                bindGLFunc!ctx( cast( void** )&ctx.glXQueryVideoCaptureDeviceNV, "glXQueryVideoCaptureDeviceNV" );
                bindGLFunc!ctx( cast( void** )&ctx.glXReleaseVideoCaptureDeviceNV, "glXReleaseVideoCaptureDeviceNV" );
                ctx.GLX_NV_video_capture= true;
            } catch ( Exception e ) {
                ctx.GLX_NV_video_capture = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_NV_video_output" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXGetVideoDeviceNV, "glXGetVideoDeviceNV" );
                bindGLFunc!ctx( cast( void** )&ctx.glXReleaseVideoDeviceNV, "glXReleaseVideoDeviceNV" );
                bindGLFunc!ctx( cast( void** )&ctx.glXBindVideoImageNV, "glXBindVideoImageNV" );
                bindGLFunc!ctx( cast( void** )&ctx.glXReleaseVideoImageNV, "glXReleaseVideoImageNV" );
                bindGLFunc!ctx( cast( void** )&ctx.glXSendPbufferToVideoNV, "glXSendPbufferToVideoNV" );
                bindGLFunc!ctx( cast( void** )&ctx.glXGetVideoInfoNV, "glXGetVideoInfoNV" );
                ctx.GLX_NV_video_output = true;
            } catch ( Exception e ) {
                ctx.GLX_NV_video_output = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_OML_sync_control" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXGetSyncValuesOML, "glXGetSyncValuesOML" );
                bindGLFunc!ctx( cast( void** )&ctx.glXGetMscRateOML, "glXGetMscRateOML" );
                bindGLFunc!ctx( cast( void** )&ctx.glXSwapBuffersMscOML, "glXSwapBuffersMscOML" );
                bindGLFunc!ctx( cast( void** )&ctx.glXWaitForMscOML, "glXWaitForMscOML" );
                bindGLFunc!ctx( cast( void** )&ctx.glXWaitForSbcOML, "glXWaitForSbcOML" );
                ctx.GLX_OML_sync_control = true;
            } catch ( Exception e ) {
                ctx.GLX_OML_sync_control = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_SGIX_fbconfig" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXGetFBConfigAttribSGIX, "glXGetFBConfigAttribSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXChooseFBConfigSGIX, "glXChooseFBConfigSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXCreateGLXPixmapWithConfigSGIX, "glXCreateGLXPixmapWithConfigSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXCreateContextWithConfigSGIX, "glXCreateContextWithConfigSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXGetVisualFromFBConfigSGIX, "glXGetVisualFromFBConfigSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXGetFBConfigFromVisualSGIX, "glXGetFBConfigFromVisualSGIX" );
                ctx.GLX_SGIX_fbconfig = true;
            } catch ( Exception e ) {
                ctx.GLX_SGIX_fbconfig = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_SGIX_hyperpipe" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXQueryHyperpipeNetworkS, "glXQueryHyperpipeNetworkS" );
                bindGLFunc!ctx( cast( void** )&ctx.glXHyperpipeConfigSGIX, "glXHyperpipeConfigSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXQueryHyperpipeConfigSGIX, "glXQueryHyperpipeConfigSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXDestroyHyperpipeConfigSGIX, "glXDestroyHyperpipeConfigSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXBindHyperpipeSGIX, "glXBindHyperpipeSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXQueryHyperpipeBestAttribSGIX, "glXQueryHyperpipeBestAttribSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXHyperpipeAttribSGIX, "glXHyperpipeAttribSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXQueryHyperpipeAttribSGIX, "glXQueryHyperpipeAttribSGIX" );
                ctx.GLX_SGIX_hyperpipe = true;
            } catch ( Exception e ) {
                ctx.GLX_SGIX_hyperpipe = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_SGIX_pbuffer" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXCreateGLXPbufferSGIX, "glXCreateGLXPbufferSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXDestroyGLXPbufferSGIX, "glXDestroyGLXPbufferSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXQueryGLXPbufferSGIX, "glXQueryGLXPbufferSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXSelectEventSGIX, "glXSelectEventSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXGetSelectedEventSGIX, "glXGetSelectedEventSGIX" );
                ctx.GLX_SGIX_pbuffer = true;
            } catch ( Exception e ) {
                ctx.GLX_SGIX_pbuffer = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_SGIX_swap_barrier" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXBindSwapBarrierSGIX, "glXBindSwapBarrierSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXQueryMaxSwapBarriersSGIX, "glXQueryMaxSwapBarriersSGIX" );
                ctx.GLX_SGIX_swap_barrier = true;
            } catch ( Exception e ) {
                ctx.GLX_SGIX_swap_barrier = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_SGIX_swap_group" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXJoinSwapGroupSGIX, "glXJoinSwapGroupSGIX" );
                ctx.GLX_SGIX_swap_group = true;
            } catch ( Exception e ) {
                ctx.GLX_SGIX_swap_group = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_SGIX_video_source" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXBindChannelToWindowSGIX, "glXBindChannelToWindowSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXChannelRectSGIX, "glXChannelRectSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXQueryChannelRectSGIX, "glXQueryChannelRectSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXQueryChannelDeltasSGIX, "glXQueryChannelDeltasSGIX" );
                bindGLFunc!ctx( cast( void** )&ctx.glXChannelRectSyncSGIX, "glXChannelRectSyncSGIX" );
                ctx.GLX_SGIX_video_source = true;
            } catch ( Exception e ) {
                ctx.GLX_SGIX_video_source = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_SGI_cushion" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXCushionSGI, "glXCushionSGI" );
                ctx.GLX_SGI_cushion = true;
            } catch ( Exception e ) {
                ctx.GLX_SGI_cushion = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_SGI_swap_control" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXSwapIntervalSGI, "glXSwapIntervalSGI" );
                ctx.GLX_SGI_swap_control = true;
            } catch ( Exception e ) {
                ctx.GLX_SGI_swap_control = false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_SGI_video_sync" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXGetVideoSyncSGI, "glXGetVideoSyncSGI" );
                bindGLFunc!ctx( cast( void** )&ctx.glXWaitVideoSyncSGI, "glXWaitVideoSyncSGI" );
                ctx.GLX_SGI_video_sync = true;
            } catch ( Exception e ) {
                ctx.GLX_SGI_video_sync= false;
            }
        }
        if ( isExtSupported!ctx( glversion, "GLX_SUN_get_transparent_index" ) ) {
            try {
                bindGLFunc!ctx( cast( void** )&ctx.glXGetTransparentIndexSUN, "glXGetTransparentIndexSUN" );
                ctx.GLX_SUN_get_transparent_index = true;
            } catch ( Exception e ) {
                ctx.GLX_SUN_get_transparent_index = false;
            }
        }
    }
}